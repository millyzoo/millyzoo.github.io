{"pages":[],"posts":[{"title":"Command Line 與 Vim 基本操作","text":"Command Line 簡單來說就是和電腦溝通的語言，而我們操作電腦的方式一般來說有兩種： 圖形使用者介面（GUI） 命令列介面（CLI） 圖形使用者介面（GUI）全名是 Graphical User Interface，是指用圖形方式顯示的電腦操作用戶介面，也是我們平常最常用來操作電腦的方式。若用更白話、簡單的方式來說，就像下圖一樣，我們要新增資料夾時，可以透過滑鼠點擊的方式來操作。 命令列介面（CLI）全名是 Command-Line Interface，是在 GUI 普及之前最廣泛運用的使用者介面，通常不支援滑鼠，而是利用鍵盤來輸入指令，電腦接收到指令後，將會執行。 CLI 學習理由對設計師、剪輯師或其他職業來說，都能使用有 GUI 的軟體來工作，但在程式開發裡，有很多工具不提供圖形介面，只能透過指令來和電腦溝通。 結論：工程師必備技能。（想想看，你有看過電影裡有哪個駭客還在慢慢用 GUI 的嗎？感覺就弱掉了對吧。） Command Line 常用指令基本指令懶人包 指令 英文縮寫來源 說明 pwd print working directory 顯示目前所在位置 ls list 列出目前資料夾底下的所有檔案 ls-al list all 列出詳細資料，包含檔案大小、修改時間、隱藏檔案… cd change directory 切換資料夾 cd .. 回到上一層資料夾 clear clear 清空終端機畫面 man manual 使用說明書 印出所在位置pwd：顯示目前所在位置（print working directory） 列出檔案清單ls：列出目前資料夾底下的所有檔案（list） ls-al：列出詳細資料在ls 後面加上參數 -al ，會列出詳細資料，例如：檔案權限、檔案擁有者、檔案大小、最後修改時間、所有隱藏檔案。 切換資料夾cd：切換資料夾（change directory） cd ..：如果在cd 後面加上 .. 的話，則能夠回到上一層資料夾 clear：清空終端機畫面，想要清空畫面的時候可以輸入這個指令。（超方便！之前不知道這個指令卻又有強迫症想清空畫面，都用很笨的方法關掉再重開終端機。） man：使用說明書（manual）舉例：輸入 man ls 後，會列出 ls 的詳細用法。 檔案操作相關指令懶人包 指令 英文縮寫來源 說明 touch 建立檔案或更改檔案時間 rm remove 刪除檔案 rmdir 資料夾名稱 remove directory 刪除資料夾 rm -r 資料夾名稱 刪除資料夾（慎用！） rm -f 刪除資料夾（超危險！） mkdir make directory 建立資料夾 mv move 移動檔案或改名 cp copy 複製檔案 date date 顯示當前時間 top table of processes 顯示所有 Process cat catenate 連接檔案或把檔案內容顯示出來 less 分頁印出檔案 echo 印出字串 建立檔案或更改檔案時間touch：建立檔案或更改檔案時間。當檔案「存在」時，輸入 touch 後，檔案修改時間將會更新。 當檔案「不存在」時，輸入 touch 後，將會新增檔案。 刪除檔案rm：remove，只要輸入 rm 檔案名稱，即可刪除檔案。 這裡記得需輸入檔案格式，如：.txt、.jpg⋯等。 rm 只能刪除檔案，如果想刪除資料夾的話有幾種作法： rmdir 資料夾名稱：remove directory，在 rm 後面加上dir rm -r 資料夾名稱：在 rm 後面加上空格+-r 若檔案本身沒有保護機制，使用 rm -r 指令會直接刪除資料夾及裡面的所有檔案。（慎用！） rm -f 即使檔案有保護機制會跳出確認訊息時，使用 rm -f 指令一樣會無視保護機制，直接刪除檔案。（超危險！） 建立資料夾mkdir：make directory，輸入 mkdir 資料夾名稱，即可建立資料夾。 移動檔案或改名mv：move，用於移動檔案或改名。 移動檔案： 更改檔案名稱： 複製檔案cp：copy，複製檔案。 指令：cp + 原本檔案名稱 + 新複製的檔案名稱範例： cp test.txt test2.txt 如果要複製「資料夾」的話，要加上 -r。指令：cp + -r + 原資料夾名稱 + 複製的資料夾名稱 顯示當前時間date：顯示當前時間。 顯示所有 Processtop：table of processes，顯示所有 Process。 連接檔案或把檔案內容顯示出來cat：catenate，連接檔案或把檔案內容顯示出來。 例如：輸入 cat jquery.js，終端機即會顯示jquery.js 裡面所有內容 分頁印出檔案less：分頁印出檔案。 因為使用 cat 指令顯示出的檔案內容可能會太佔據終端機版面，可以使用這個指令進入閱讀模式，並可按 :q 退出模式，也不會佔據到終端機版面 印出字串echo：印出字串。 Command Line 其他好用指令抓取關鍵字grep：抓取關鍵字。 指令：grep + 關鍵字 + 檔案名稱 使用情境示範：有一個 hello.txt 的文字檔案，內含許多文字，今天我要找出關鍵字 oh 的話，該怎麼做呢？ 輸入：grep + oh + hello.txt，即會顯示出擁有 oh 這個關鍵字的所有字句。 下載檔案wget：下載檔案，非內建指令，需要先安裝。 指令：wget + 想要下載的圖片網址或檔案網址 送出 requestcurl：送出 request。 指令組合技串接指令pipe:|：串接指令，可以把前面的輸出變成後面的輸入。 例如：cat file.txt | grep hi把前面使用 cat 印出的檔案內容，用 grep 抓取關鍵字出來 重新導向redirect: &gt;：重新導向redirection： 重新導向 input output （寫給自己看：這部分有空再回去看 [CS101] 2-4） Vim 文字編輯器Vim 是一款歷史悠久，並由 Vi 發展出來的文字編輯器，也是 Git 預設的編輯器。雖然目前已有許多文字編輯器能夠使用，例如：VS Code、Sublime Text 等，但很多人在使用 Git 過程中，可能會不小心進入這個編輯器，而這個編輯器的使用方式相較其他文字編輯器來說比較特別，需要透過特定指令才能達到輸入文字、存檔，甚至是離開的動作。 Vim 的基本操作 常用模式Vim 至少有超過五種以上的模式能夠應用，這邊只簡單介紹三種最常使用的模式： 普通模式（預設模式）：無法打字的狀態 插入模式：可輸入文字，按 ESC 鍵可回普通模式 命令行模式：可輸入以下所提到的常用指令使用 常用指令 :q：不存檔，直接離開 :q!：不存檔，強制離開（當有修改不想儲存時） :w：存檔，但不離開 :!w：強制存檔，但不離開 :w {name}：存檔並命名為 name，但不離開 :wq：存檔並離開 :!wq：強制存檔並離開 其他未提及的指令及模式可自行查閱。 參考： Huli－紮實的網頁前端學習路線與資源推薦 維基百科：Vim 超簡明 Vim 操作介紹 簡明 Vim 文字編輯器操作入門教學","link":"/Others/Command%20Line%20%E8%88%87%20Vim%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"JavaScript - == 與 === 的差別","text":"在提 == 和 === 的差別前，先看這段程式碼： 12let a = 10console.log(a = 1) // 印出 1 以這段程式碼來說，程式解讀的順序會是 先跑 a = 1 &gt; 再跑 console.log(a) &gt; 所以最後 console.log 會得到 1 那如果是這段程式碼： 12let a = 10 == 10console.log(a) // 印出 true 因為程式會先從右邊執行到左邊，10 == 10 為 true，所以 a = true。為了程式碼可讀性，建議先用括弧框起來，例如：let a = (10 == 10) == 與 === 的差別==（一般相等）：會轉換型態，== 會先將值轉換成同個型態再做比較，用來寫程式容易有 bug。===（嚴格相等）：不會轉換型態，除了值以外，型態也一定要相同，否則會被視為不相等。 （強烈建議開發時使用 === 來寫） 1234560 == '0' // true，因為型態已被轉換過0 === '0' // false，型態不同0 == '' // true0 === '' // false2 == '2' // true，因為型態已被轉換過2 === '2' // false，型態不同 object 物件 1234567let obj = { number: 1}let obj2 = objobj.number = 2console.log(obj === obj2) // 印出 true，因為比較的是記憶體位置 array 陣列 12345678910111213141516171819let arr = []let arr2 = []console.log(arr === arr2) // 印出 false，因為比較的是記憶體位置let arr = [1]let arr2 = [1]console.log(arr === arr2) // 印出 false，因為比較的是記憶體位置---let arr = [1]let arr2 = [1]arr2 = arr // 賦值console.log(arr === arr2) // 印出 true---// 同上述理論console.log([] === []) // 印出 falseconsole.log({} === {}) // 印出 false 推薦網站：JS Comparison Table，裡面列出 == 與 === 對照的值。 等號判斷的 Edge Case：NaNNaN：雖然是 Not a Number 的縮寫，但其實型態仍為 Number。 1console.log(typeof NaN); // 印出 number NaN 在等號判斷有個 Edge Case，無法解釋，可以當作特殊規則來記。 123456789let a = Number('hello')console.log(a === a) // 印出 false// 其原理是因為 NaN 連自身都不等於 NaNconsole.log(NaN === NaN) // 印出 false// 如果在不是 NaN 的狀況就會正常，例如：let a = 1console.log(a === a) // 印出 true 如何判斷是否為 NaN可以使用：isNaN()，如果是 NaN 就會顯示 true；否就顯示 false（有些舊的瀏覽器可能不支援，就得找其他方法） 12let a = Number('hello')console.log(isNaN(a)) // 印出 true 什麼狀況會出現 NaN 呢？12345let a = Number('101')let b = Number('hello')console.log(a) // 印出 101console.log(b) // 印出 NaNconsole.log(typeof b) // 印出 number 型態","link":"/Front-End/JavaScript%20-%20==%20%E8%88%87%20===%20%E7%9A%84%E5%B7%AE%E5%88%A5/"},{"title":"JavaScript - 宣告變數的方式與作用域（Scope）","text":"早期宣告變數都使用 var 來宣告，但自從 ES6 出現後，多了兩個新選擇：const（宣告常數）及 let（宣告變數）。 常數 const（constant） 變數 var（variable） let ES6 後才出現的 let 和 ES6 之前的 var 有什麼差別呢？ var 與 let、const 最大的差別就是 作用域（Scope）的定義不同。var 的作用域範圍是 Function Scope。let 或 const 的作用域範圍是 Block Scope，所謂的 Block Scope 就是變數的作用範圍只存在兩個大括號 { } 中。 作用域 說明 var Function Scope function { } let 與 const Block Scope { } （給自己看：有空再補圖解） 常數 constconst（constant）是常數，值是不能改變的，且一定要先給初始值，不可事後才給 1234// 值是不能改變的const b = 20b = 30// 會有錯誤提示 TypeError: Assignment to constant variable 1234// 一定要先給初始值，不可事後才給const bb = 30// 會有錯誤提示 SyntaxError: Missing initializer in const declaration 123456789101112const obj = { number: 1}obj.number = 2// 不會有錯誤提示，因為記憶體位置一樣const obj2 = { number: 1}obj2 = { number: 2 }// 會有錯誤提示 TypeError: Assignment to constant variable// 記憶體位置改變，代表值也換了 關於記憶體位置，可以參考之前寫的 JavaScript - 變數的資料型別與賦值 其中 Object 的內容 變數 var 與 let目前宣告變數的方式有兩種，var（variable）以及 let，兩者最大的差別是Scope（作用域） 什麼是 Scope（作用域）？作用域簡單來說是變數的生存範圍 先談 ES6 以前的作用域在 ES6 出現前只能使用 var 來宣告，其作用範圍是 Function Scope，只有 function 可以產生新的作用域。這是什麼意思呢？來看看範例： 123456function test() { var a = 10 console.log(a)}test() // 印出 10console.log(a) // 會出現 ReferenceError: a is not defined 因為 a 宣告在 function 裡面，a 只有在這個函式裡面，才能被大家看見，所以一旦離開函式，就會找不到 a 的變數宣告。 問題：如果變數宣告在外面呢？ 變數宣告在外面的話即是 global variable 全域變數，代表所有人都看得見它。而作用域的特性是從內層開始往外層找，當在 test() 裡面找不到 a 的宣告時，就會往上一層找，便能找到全域變數的 a，所以 console.log(a) 就能順利顯示。 123456var a = 10function test() { console.log(a)}test() // 印出 10console.log(a) // 印出 10 其他範例： 1234567var a = 20function test() { var a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 20 特別要注意的範例這段程式碼的執行順序：執行 test() &gt; 找到 test function &gt; 函式裡面沒有宣告 a&gt; 往外找到 var a = 20 並帶入函式 &gt; 用賦值去改變 a &gt; 所以 a 已經被改變成 10 1234567var a = 20function test() { a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 10 如果沒有宣告變數，JavaScript 會自動把 a 轉成全域變數，但這樣容易出現 bug，不建議這樣做 123456function test() { a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 10 Scope chain（範圍鏈）就是指變數從最裡面往外找的行為 1234567891011121314151617var a = 'global'function test() { var a = 'test scope a' var b = 'test scope b' console.log(a, b) function inner() { var b = 'inner scope b' console.log(a, b) } inner()}test()console.log(a)// 印出：// test scope a test scope b// test scope a inner scope b// global Scope（作用域）容易把和其他觀念混淆之處： 1234567891011var a = 'global' // global scopefunction change() { // change scope var a = 10 test()}function test() { // test scope console.log(a)}change() // 最後會印出 global 關於 test() 的範圍鏈： 初學者以為的是 test scope -&gt; change scope -&gt; global scope （錯誤） 正確的範圍鏈是 test scope -&gt; global scope change() 和 test() 是平行世界， 在哪裡呼叫沒有關係 ES6 出現後的作用域以下使用 var 為範例： 12345678function test() { var a = 60 if (a === 60) { var b = 10 } console.log(b)}test() // 印出 10 接下來改以 let 宣告測試：因為 b 只存在 if (a === 60) { } 的判斷式裡面，所以在外面的 console.log(b) 就找不到 b 12345678function test() { var a = 60 if (a === 60) { let b = 10 } console.log(b)}test() // 會有錯誤提示 ReferenceError: b is not defined 其他範例：當 i 變成 3 時，就不符合條件而跳出迴圈，所以最外面的 final value 即會得到 3 123456789101112function test() { for (var i = 0; i &lt; 3; i++) { console.log('i:', i) } console.log('final value:', i)}test()// 印出：// i: 0// i: 1// i: 2// final value: 3 如果改成 let，因為 i 只存在 for 迴圈裡面，一跳出迴圈就會變成未定義的變數： 123456789101112function test() { for (let i = 0; i &lt; 3; i++) { console.log('i:', i) } console.log('final value:', i)}test()// 印出：// i: 0// i: 1// i: 2// ReferenceError: b is not defined","link":"/Front-End/JavaScript%20-%20%E5%AE%A3%E5%91%8A%E8%AE%8A%E6%95%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89/"},{"title":"JavaScript - 淺談 Hoisting","text":"之前在 《JavaScript - 宣告變數的方式與作用域（Scope）》 中提到變數有作用域的特性，這次則要來認識 Hoisting（提升）的概念。 什麼是 Hoisting？在解釋 Hoisting 前，先來看看範例：如果沒有宣告就呼叫 b，會得到 b is not defined（未定義） 1console.log(b) // ReferenceError: b is not defined 那如果先呼叫再宣告呢？ 12console.log(b)var b = 10 // undefined undefined 會出現的狀況是「已宣告卻尚未給值」，按照程式碼邏輯是由上往下執行，明明是先呼叫才宣告，怎麼會是 undefined 呢？ 這樣的現象就稱為 Hoisting（提升）。但只有宣告會提升，賦值是不會提升的 Hoisting（提升）還有一個顯而易見的範例： 12345test()function test() { console.log(123)} 我們可以在宣告 function 前就先呼叫，這也是 Hoisting 的特性。 如果是： 123456test()var test = function() { console.log(123)}// 執行結果 TypeError: test is not a function","link":"/Front-End/JavaScript%20-%20%E6%B7%BA%E8%AB%87Hoisting/"},{"title":"JavaScript - 認識運算子","text":"此篇內容主要記載五種 JavaScript 運算子種類（算術、位元、位移、邏輯、條件）。 文章目錄 關於 false 算術運算子 位元運算子 位移運算子 邏輯運算子 條件運算子（三元運算子） 關於 false因為文章內會出現大量布林值，在深入了解運算子之前，我們要先知道什麼狀況會被當成 false。在 JavaScript 中，以下這些都會被當作是 false： null 0 NaN ''(空字串) undefined 算術運算子 運算子 說明 範例及說明 + 加法 2 + 3 回傳 5 - 減法 6 - 4 回傳 2 ++ 遞增 假如 x 是 3，那 ++x 將把 x 設定為 4 並回傳 4，而 x++ 會回傳 3 ， 接著才把 x 設定為 4 -- 遞減 假如 x 是 3，那 –x 將把 x 設定為 2 並回傳 2，而 x– 會回傳 3 ， 接著才把 x 設定為 2 * 乘法 2 * 5 回傳 10 / 除法 10 / 2 回傳 5 % 取餘數 10 % 3 回傳 1 ** 次方 2 ** 5 回傳 32 ++ 與 -- 123var a = 0a = a + 5 // 這句話可省略成：a += 5a = a - 5 // 這句話可省略成：a -= 5 a++（就是 a += 1），a– 反之 注意，++ 放前面或放後面的意思是不同的 位元運算子 運算子 符號 用法 AND &amp; a &amp; b OR XOR ^ a ^ b NOT ~ ~ a （說明待補） 位移運算子 運算子 用法 左移 a &lt;&lt; b 右移 a &gt;&gt; b 為什麼要用這個位移運算子？比起使用 * 這個符號，對於電腦來說二進位是電腦最原始的形式，所以使用位移運算子的效能會比較快。 右移 &gt;&gt; 與左移 &lt;&lt;&gt;&gt; 右移 n 位：可以想成乘以 2 的 n 次方&lt;&lt; 左移 n 位：可以想成除以 2 的 n 次方 範例： 123410 &lt;&lt; 1 // 回傳 2010 &lt;&lt; 3 // 回傳 80，這裡的 3 代表 2^31 &lt;&lt; 10 // 回傳 1024，這裡的 10 代表 2^101024 &gt;&gt; 1 // 回傳 512 邏輯運算子邏輯運算子總共有三個，分別是：AND、OR 與 NOT，通常被用於布林值（true / false），使用於布林值時， 它們會回傳布林型態的值。 1. 邏輯 OR (||)OR (||) 是「或」的意思，只要其中一邊是 true，即會是 true。 123true || true // 回傳 truetrue || false // 回傳 truefalse || true // 回傳 true OR (||) 的短路求值 短路求值是一種邏輯運算符的求值策略。只有當第一個運算數的值無法確定邏輯運算的結果時，才對第二個運算數進行求值。（取自維基百科） OR (||) 除了可以回傳布林值以外，其他類型也能做邏輯運算子。如果第一個遇到的值即為 true，即會回傳 true，不需再理會第二個值；如果兩邊都是 true，也會回傳第一個值。 123453 || 10 // 3 是 true，所以回傳 3false || 5 // 5 是 true，所以回傳 50 || 10 // 數值 0 在 JavaScript 中會被當作 false，所以回傳 10false || 10 // 回傳 101 == 2 || \"hello\" // 回傳 \"hello\" 設定變數預設值可以用於取代 if 判斷式，例如： 1let fruit = apple || banana 以上的意思是指，如果 apple 不存在就回傳 banana 簡化程式碼如果 obj 是 false 就呼叫 call() 函式 123if (!obj) { call()} 可以直接簡化成： 1(obj || call()) 同理，如果反過來是： 123if (obj) { call()} 就可以簡化成： 1(!obj || call()) 2. 邏輯 AND (&amp;&amp;)AND (&amp;&amp;) 的規則是兩個條件皆符合才會成立，所以第一個條件若不符合，程式碼就不會再往後執行。 第一個條件是 true 的話，就直接回傳第二個條件的數值 第一個條件是 false，就會回傳 false，而不再往後看後面的條件 1234567true &amp;&amp; true // 回傳 truetrue &amp;&amp; false // 回傳 false3 &amp;&amp; 10 // 回傳 1010 &amp;&amp; 3 // 回傳 3false &amp;&amp; 3 // 回傳 false3 &amp;&amp; false // 回傳 false0 &amp;&amp; 100 // 回傳 false，因為 0 在 JavaScript 中被當成 false 簡化程式碼原本是： 1234let a = 5;if (a == 5) { alert(\"a = 5\");} 可以簡化成： 12let a = 5;a == 5 &amp;&amp; alert(\"a = 5\") 原理是如果 a == 5 為 false，就不會執行後面的程式碼了 3. 邏輯 NOT (!)12!true // 負正得負，所以回傳 false!false // 負負得正，所以回傳 true 條件運算子（三元運算子）三元運算子可以當成 if … else 的簡化寫法語法是： 條件 ? 值 1 : 值 2 範例：原本用 if … else 的寫法 12345if (a &gt; b) { return \"yes\"} else { return \"no\"} 可以用三元運算子簡化成 1return a &gt; b? \"yes\" : \"no\" 參考： MDN - 運算式與運算子 Javascript 基礎打底系列 (三) - 邏輯運算子，與短路邏輯 (short circuit logic)","link":"/Front-End/JavaScript%20-%20%E8%AA%8D%E8%AD%98%E9%81%8B%E7%AE%97%E5%AD%90/"},{"title":"JavaScript - 變數的資料型別與賦值","text":"目錄 什麼是變數 變數的資料型別 原始型別（Primitive Type） object 物件 檢測變數的型別 賦值 = 變數與賦值原理 變數運算小陷阱 什麼是變數可以將變數想像成「一個能夠裝東西的箱子」，我們可以幫這個箱子命名（例如：box），箱內能儲存一些東西，這樣就可以用我們命名的 box 來代指箱子裡所儲存的東西。 有宣告變數卻沒有賦值的話，n 的值會變成 undefined 12let aconsole.log(a) // 印出 undefined 沒有宣告變數就直接使用會出現 ReferenceError: __ is not defined（未定義） 1console.log(a) // 出現 Uncaught ReferenceError: a is not defined 變數的資料型別變數沒有型別，值才有。 最新的 ECMAScript 標準定義了七種資料型別： 原始型別（Primitive Type） null undefined string number boolean symbol Object 物件 Primitive Type 和 object 的差別之一：Primitive Type 是不可改變的（Immutable） 123456789// Primitive Type 不可改變let str = 'hello'str.toUpperCase() //這一行回傳的是新的值，而不是改變舊的自己console.log(str) // 印出 hello// object 可以改變let arr = [1]arr.push(2)console.log(arr) // 印出 [1, 2] 原始型別（Primitive Type） 型別 名稱 說明 數值範例 Null 沒有值 「現在」沒有值（可能曾經有過） Undefined 未定義 已宣告卻尚未給值 String 字串型別 需用單引號或雙引號包夾住 “Hello”、’Hi’ Number 數字型別 除了常見的整數與小數點外，還包含 Infinity（無限大）、-Infinity（負無限大），以及 NaN 50、100 Boolean 布林值 值有 true 及 false 兩個值 true / false Symbol 符號型別 ES6 新推出的資料型別 Object 物件 Object 物件 { } Array 陣列 [ ] Function 函式 function() {} Date 除了基本型別 (Primitives) 以外的值都是物件 檢測變數的型別 typeof Array.isArray([])（因為 typeof 沒辦法辨識 array，就可以使用這個語法來判斷 array） Object.prototype.toString.call() typeof如果想查詢變數是什麼型別可以用 typeof + 變數 來查詢。 1234console.log(typeof 30) // 印出 numberconsole.log(typeof 'Hello') // 印出 stringconsole.log(typeof undefined) // 印出 undefinedconsole.log(typeof true) // 印出 boolean 以下是幾個 typeof 令人容易混淆的地方（詳情可參考 MDN - typeof） 123console.log(typeof null) // 印出 object，這是 JavaScript 的「bug」console.log(typeof function(){}) // 印出 function（除了 function 以外的物件都是回傳 object）console.log(typeof []) // 印出 object，因為陣列歸類在 object 型別 從 typeof 沒辦法判斷變數是不是 array，所以可以利用 Array.isArray([]) 來判斷。（比較舊的瀏覽器可能不支援這個語法） 1console.log(Array.isArray([])) // 印出 true 變數使用 typeof 12console.log(a) // RefereneceError: a is not definedconsole.log(typeof a) // 印出 undefined 12let aconsole.log(typeof a) // 印出 undefined，雖然有宣告，但沒有賦值 開發時可以利用 typeof 來檢查變數有沒有賦值： 12345678910if (typeof a !== 'undefined') { console.log(a)}// 因為沒有賦值，所以不會回傳任何東西//如果不用 `typeof` 來判斷，會跑出 RefereneceError：if (a !== 'undefined') { console.log(a)}// 印出 RefereneceError: a is not defined 12345let a = 10if (typeof a !== 'undefined') { console.log(a)}// 印出 10 Object.prototype.toString.call()12345console.log(Object.prototype.toString.call(1)) // 印出 [Object Number]console.log(Object.prototype.toString.call()) // 印出 [Object String]console.log(Object.prototype.toString.call([])) // 印出 [Object Array]console.log(Object.prototype.toString.call(new Date())) // 印出 [Object Date]console.log(Object.prototype.toString.call(null)) // 印出 [Object Null] 賦值 =在 JavaScript 中，變數的 = 並不是指數學符號的 =，指的是賦值。初學者可能會有誤把 = 當成 等於 的狀況使用，需要特別注意！ 12345let a = 10if (a = 20) { // 此處是「賦值」 console.log(123)}// 印出 123 變數與賦值原理Primitive Type12345678910111213let a = 10let b = a// a: 10// b: 10（從 a copy 過去的）--------------- // 所以當給 b 一個新的值時，就會直接改變let a = 10let b = ab = 20// a: 10// b: 20 Object12345678let obj = { number: 10}let obj2 = objconsole.log(obj, obj2) // 印出 { number: 10} { number: 10} obj.number = 20console.log(obj, obj2) // 印出 { number: 20} { number: 20} 上述程式碼的解析： 123456789101112131415161718let obj = { number: 10}// obj 的內容 {number: 10} 其實是放到某個記憶體位置上// 這裡先以 0x01 代表記憶體位置0x01: { number: 10}obj: 0x01 // 所以 obj 指的是 0x01 記憶體位置的東西let obj2 = obj // 當 obj2 宣告 = obj 時obj2: 0x01 // 其實是 copy obj 的記憶體位置obj.number = 20 // 其實是改變記憶體中的 number0x01: { number: 20}// 因此記載同樣記憶體的 obj 也會被影像// 所以 console.log(obj, obj2) 會印出 { number: 20} { number: 20} array 也是 object 的一種，所以同理可證： 12345let arr = []let arr2 = arrconsole.log(arr, arr2) // 印出 []arr2.push('arr2')console.log(arr, arr2) // 印出 ['arr2', 'arr2'] 小陷阱： 12345let arr = []let arr2 = arrconsole.log(arr, arr2) // 印出 []arr2 = ['arr2'] // 賦值原理：['arr2'] 是放在新的記憶體位置，此時 arr2 存取的記憶體位置和 arr 不同了console.log(arr, arr2) // 印出 [] [ 'arr2' ] 變數運算小陷阱在使用變數做運算時，初學者容易忽略的陷阱有兩個，一是型別，二是浮點數誤差。 型別123let a = 10let b = '20'console.log(a + b) // 印出 1020，因為 b 是字串，所以不會印出 30 浮點數誤差電腦在儲存小數點時沒有辦法真的很精準，所以會導致運算結果有些許誤差。 12let a = 0.1 + 0.2console.log(a == 0.3) // 印出 false 為什麼是 false 呢？我們把 a 拆解來看，會發現奇妙的誤差，因此在使用小數點時需特別注意，或盡量減少使用小數點。 1console.log(a) // 印出 0.3000000004 參考：重新認識 JavaScript: Day 03 變數與資料型別","link":"/Front-End/JavaScript%20-%20%E8%AE%8A%E6%95%B8%E7%9A%84%E8%B3%87%E6%96%99%E5%9E%8B%E6%85%8B%E8%88%87%E8%B3%A6%E5%80%BC/"},{"title":"基礎環境建置 – Terminal、Git","text":"俗話說工欲善其事，必先利其器，在開始學習程式之前，先來建置電腦環境吧！（這篇筆記主要記載建置環境時遇到的疑難雜症。） 安裝的工具總共有： Homebrew（macOS 系統的套件管理工具） Git（一套能夠管理檔案的版本的程式 ） iTerm2（用於取代 MAC 原生終端機的工具） zsh（Z shell－維基百科） oh-my-zsh（zsh 的懶人包版本，已經先載好一些主題、外掛和設定） 安裝 Git安裝 Git 的方法有幾種，我選擇的方法是按照 Git 官網 說明，利用 Homebrew 套件管理工具來進行安裝，安裝完畢後按照指示在終端機輸入 $ brew install git ，並完成 Git 安裝。 這邊要特別注意的是，如果安裝過程出現 git -bash: $: command not found 時，請記得把 $ 拿掉。 iTerm2因為 Mac 本身內建的終端機樣式較少，所以可以自行斟酌是否要安裝其他 Terminal，這邊推薦使用 iTerm2，安裝方式我參考 超簡單！十分鐘打造漂亮又好用的 zsh command line 環境 來進行安裝，但因為文章比較舊，在安裝過程上有一些步驟需要更新，以下紀錄我所遇到的問題及解法： 1. 字體安裝遇到字體安裝的問題，在原文中安裝的步驟是寫： # 先執行這行，才能用 homebrew 安裝字型（曾經執行過的人可以跳過這個指令）brew tap caskroom/fonts# 安裝指令brew cask install font-sourcecodepro-nerd-font 但實際運行 brew tap caskroom/fonts 這句時，卻會報錯出現 Error: caskroom/fonts was moved. Tap homebrew/cask-fonts instead. 解法：brew tap caskroom/fonts 改成 brew tap homebrew/cask-fonts 即可解決 2. 安裝其他字型文中所提到若想安裝其他字型可輸入 brew cask search nerd 來搜尋，但此指令已不能再使用，需 解法：改為 brew search nerd 安裝 zsh theme安裝完 oh-my-zsh 後，最後就是安裝 zsh theme 的步驟，可是在安裝 zsh theme 時，因為對終端機指令不太熟悉，我卡很久，一直不太懂編輯 ~/.zshrc 是什麼意思，後來才知道這是一個隱藏的檔案，需要先打開來做設定。 打開 ~/.zshrc 的方式有兩種： 打開 Finder，按下快捷鍵 Command ⌘ + Shift + . ，即可顯示出隱藏檔案 .zshrc。 在 Terminal 直接輸入 open ~/.zshrc，系統即會直接打開檔案。 環境建置完成以上問題皆排除後，即可完成基礎環境建置。 參考： 安裝 homebrew cask 報錯問題 brew caskでフォントを入れる方法 #homebrew brew cask search が使えなくなったので brew search を使います [心得] iTerm2 + zsh，打造更好的工作環境","link":"/Others/%E5%9F%BA%E7%A4%8E%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE%E2%80%93Terminal%E3%80%81Git/"},{"title":"認識版本控制與 Git 時光機","text":"什麼是版本控制？ 版本控制指的是把製作過程中的每個版本都保存下來，主要分成個人或團隊的版本控制。 一個人的版本控制版本控制是每個人從學生時期就學會的技能。「版本控制？我真的沒學過耶？」你可能會這麼說。 來，我們先看張圖： 不管是什麼類型的檔案格式，有沒有覺得這個畫面似曾相識？以前在繳交報告前，是不是前前後後備份了好幾個版本？其實這也是版本控制的一種，缺點是沒辦法清楚看見每個版本的差異性，時間久了也難以管理。 團隊的版本控制（待補圖） 什麼是 Git？Git 是一套能管理檔案版本，並達到做版本控制的程式，除了可以作為個人使用，也能用在多人協作上。 Git 紀錄的不是整份檔案，而是「檔案的異動」 Git 的優點： 免費 開源 速度快 檔案體積小 分散式系統 開始時光機旅程首先，先建立一個需要版本控制的目錄，開始這次的使用 Git 練習。 資料庫初始化git init：初始化目錄，讓 Git 對這個目錄開始進行版本控制。使用完這個指令後，主目錄裡面將會出現一個隱藏的 .git 目錄，裡面的內容是整個 Git 的精華，也是用這些內容來進行版本控制的。 如果這個目錄不想再使用 Git 控制呢？只要把 .git 目錄刪除即可。 ※ 注意：整個專案目錄內，任何檔案刪除都有辦法回朔，但誤把 .git 刪除就真的沒辦法了。 查詢狀態git status：查詢當前目錄的狀態。 常使用的指令，建議有事沒事就可以使用這個指令確認狀態。 把檔案交給 Gitgit add：決定檔案是否進行版本控制。 假設目前有這些檔案：code.jsnote.txtstyle.css 先把以上檔案移至目錄內，並輸入 git status 查詢狀態，即可得到這些檔案目前未被版本控制的訊息。 接下來輸入 git add code.js ，讓 code.js 加入版本控制並查看狀態，會發現檔案被分成兩個區域： staged：（有版本控制） untracked（沒有版本控制） 不小心忘記的話，CLI 畫面上很貼心的提示了取消版本控制的指令：git rm --cached &lt;檔案&gt; 如果不想要一個一個檔案慢慢輸入的話，可以輸入 git add .，即可一口氣把目前所在目錄中的所有檔案都加入版本控制。 新建一個版本git commit：新建一個版本。 當專案都完成了以後，就可以輸入 git commit 開始建立第一個版本，輸入完會進入 Vim 編輯器，可以把比較長的 commit message 在 Vim 裡面輸入，如果不想進去 Vim 裡面，可以直接輸入 git commit -m \"想要輸入的 commit message\"（推薦）。 完成後再輸入一次git status 確認狀態，即會發現不同之處。 Before After 注意！只要有更新都要照這些指令完成版本控制： git add &lt;file&gt; 或 git add . git commit + 進入 Vim 裡面輸入 commit message（或輸入 git commit -m \"想要輸入的 commit message\"，差別在於不進入 Vim） 組合指令：git commit -am '想要輸入的 commit message' 查看歷史紀錄git log：查看檔案詳細資訊。輸入後會進入詳細資訊的畫面查看，內容包含：包含版本號碼、作者、提交時間、commit message，離開的話可以按 :q 離開 git log --oneline：查看檔案重要資料。這個指令和 git log 的差別是只會顯示 7 碼版本號碼、commit message。 進入時光機如果玩過單機遊戲的應該都聽過 SL大法（Save、Load），git checkout 這個指令就是 Git 版的 Load 法（讀取紀錄），能夠輕鬆切換版本的重要指令。 git checkout + 版本號碼：切換至指定版本 git checkout master ：切換到最新版本 Git 中的邊緣人.gitignore：任何放在裡面的檔案都不會加到版本控制 使用方式： 先建立 .gitignore 檔案 用 vim 打開 .gitignore 編輯 在裡面輸入不加入版本控制的檔名 存檔後使用 git status 檢查 此指令大多用來放置不重要的檔案，例如：作業系統相關檔案、使用者個人設定、電腦暫存檔等 比對兩個版本之間的差異git diff：用來查看版本間的差異。 參考：30 天精通 Git 版本控管 (09)：比對檔案與版本差異 Git 基本流程懶人包 git init 建立 .gitignore，把不需加入版本控制的檔案先放入 輸入 git add .，先把所有檔案加入追蹤 輸入 git commit -am 'commit message' 建立版本控制 如此即完成專案第一個版本 如果有新增的檔案：一定先輸入 git add &lt;file&gt; 或 git add .，再打 git commit -am 'commit message' 如果僅編輯現有檔案：直接打 git commit -am 'commit message' 就好 Git 時光機進階篇 - 使用 Branch為什麼需要 Branch？在一個專案確定上線後，如果中途遇到 Bug 想修正，或者想要新增功能時，如果直接在專案上修正或測試，可能會影響到使用者，最理想的方式是建立分支，並在分支測試及開發，最後確認沒問題再合併回原本的專案，就不會影響到使用者。 指令介紹git branch + 名稱：建立新的 Branchgit branch -v：看目前有哪些 Branch 可簡寫指令成：gb -v git branch -m &lt;新名稱&gt;：修改 branch 的名字 git branch -d + 名稱：可以刪除指定的 Branchgit checkout + branch名稱：可以切換到指定的 Branch git merge：將 Branch 分支合併進 Master 版本 發生衝突：conflict在使用 git merge 後可能會遇到提示寫說conflict，代表兩個版本有衝突，解決方式是手動修改完成，存檔再 commit 即可。 使用分支進行專案開發新功能的流程 先使用 git branch &lt;branch 名稱&gt; 來建立新的 Branch git checkout，切換到新的 Branch 繼續開發新功能 開發完成後，git checkout 回原本的 Master git merge + 新 Branch 名稱，把新的 Branch 合併回 Master 沒衝突即完成（若有衝突就先解決完衝突再存檔並 commit 即可） Git 狀況劇commit 了，但是想再修改 commit message輸入 git commit --amend，會開啟 Vim 編輯模式，即可修改 commit message commit 後，反悔不想 commit 了git reset HEAD^：回到上一個 commit，還原檔案狀態 可以在後面加上模式： --soft（完整指令：git reset HEAD^ --soft） 這個指令的好處是，會保留檔案修改過的時候，但又能恢復到 commit 前（最常使用的做法） --hard（完整指令：git reset HEAD^ --hard），代表強制回去上一個 commit，把剛剛反悔的 commit 當作沒發生過，修改的檔案也會恢復未修改的狀態(最極端的做法) 欲了解詳情可以參考：【狀況題】剛才的 Commit 後悔了，想要拆掉重做… 還沒 commit，但修改的東西不想要了git checkout -- &lt;file&gt;：還原 “檔案內容” 客製化各個階段：Git hook什麼是 Hook？發生某件事的時候通知我（例如：有人 push 時、有人 commit 時） 指令懶人包 指令 說明 用法 init 初始化目錄 git init status 查詢當前目錄的狀態 git status init 決定檔案是否進行版本控制 git add add 初始化目錄 git init 參考： Git 教學 - Git 書 - 為你自己學 Git | 高見龍 gitbooks","link":"/Others/%E8%AA%8D%E8%AD%98%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%88%87%20Git%20%E6%99%82%E5%85%89%E6%A9%9F/"}],"tags":[{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"程式導師計畫","slug":"Lidemy","link":"/tags/Lidemy/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[{"name":"Others","slug":"Others","link":"/categories/Others/"},{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"}]}