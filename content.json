{"pages":[],"posts":[{"title":"CSS 預處理器 - SASS 基本語法介紹","text":"此篇將介紹 SASS 常用指令 Sass 指令編譯此指令只會編譯一次 1$ sass main.scss main.css 即時編譯如果需要即時編譯，可以加入參數 --watch，就不需要每次存檔都要再打一次指令 1$ sass --watch main.sass main.css 即時編譯至指定資料夾在檔案前面加上路徑即可編譯至指定資料夾（意思是將 sass 資料夾中的 main.sass 即時編譯至 css 資料夾並，命名為 main.css） 1$ sass --watch sass/main.sass css/main.css 巢狀結構的運用範例一1234567.test .test1 font-size: 1rem .test2 font-size: 1rem .test3 font-size: 1rem 編譯後 123456789.test .test1 { font-size: 1rem;}.test .test2 { font-size: 2rem;}.test .test3 { font-size: 3rem;} 範例二1234567.test &amp;.test1 font-size: 1rem &amp;.test2 font-size: 1rem &amp;.test3 font-size: 1rem 編譯後 123456789.test.test1 { font-size: 1rem;}.test.test2 { font-size: 2rem;}.test.test3 { font-size: 3rem;} &amp; 的用法（適合搭配 BEM 命名）SASS 寫法 1234567.test &amp;1 font-size: 1rem &amp;2 font-size: 1rem &amp;3 font-size: 1rem 編譯後 123456789.test1 { font-size: 1rem;}.test2 { font-size: 2rem;}.test3 { font-size: 3rem;} 註解分為兩種： // 編譯後不會顯示在 css 檔案中 /* */ 編譯後會在 css 中顯示，使用時需注意 Sass 模組化import 引入當專案規模越大時，可以將檔案拆解以便管理（例如：變數、mixin、Extend、function）為了好辨識出拆解的檔案，命名慣例是在檔案名稱前面加底線 _（例如：_variables.sass） import 的使用方式：@import 檔名，後面不需再加上副檔名範例：@import _variables，即可引入完成 使用 import 要特別注意前後位置的擺放，以免位置錯誤導致變數失效 @extend 繼承 適用時機：用於建立出共用模板 使用方法：%變數名稱，並在裡面寫出 CSS 123456%btn margin: 1rem padding: 1rem 2rem color: $background font-size: 1rem transition: .1s 利用 extend 將模板引入 1234567.btn &amp;-primary @extend %btn &amp;-secondary @extend %btn &amp;-warning @extend %btn 編譯後 123456789.btn-warning,.btn-secondary,.btn-primary { margin: 1rem; padding: 1rem 2rem; color: #eeeeee; font-size: 1rem; transition: 0.1s;} extend 搭配數值微調12345678910.btn &amp;-primary @extend %btn text-align: left // 微調的地方 &amp;-secondary @extend %btn text-align: center // 微調的地方 &amp;-warning @extend %btn text-align: right // 微調的地方 編譯後，extend 會很聰明的只把不同的 CSS 獨立出來！ 123456789101112131415161718.btn-warning,.btn-secondary,.btn-primary { margin: 1rem; padding: 1rem 2rem; color: #eeeeee; font-size: 1rem; transition: 0.1s;}.btn-warning { text-align: left;}.btn-secondary { text-align: center;}.btn-primary { text-align: right;} @mixin 管理屬性 適用時機：大量重複使用的屬性，卻需要數值做微調 使用方法： @mixin 自定義名稱，並將需要重複的 CSS 放在裡面 在後面加上 ()，在其中放入參數，即可做出客製化設定 和 extend 有點雷同，但 extend 是以逗號隔開，共用同一段 CSSmixin 則會獨立分開，mixin 更適合運用在帶變數的情況 123@mixin hover-btn($color) &amp;:hover background: $color 1234567.btn &amp;-primary +hover-btn($primary) &amp;-secondary +hover-btn($secondary) &amp;-warning +hover-btn($warning) 編譯後 123456789.btn-primary:hover { background: #000000;}.btn-secondary:hover { background: #eeeeee;}.btn-warning:hover { background: red;} 注意！使用 mixin 時，記得先宣告再使用。 @include 引入 需搭配 @mixin 使用，先定義好 @mixin，再透過 @include 呼叫使用。 若定義的 @mixin 有設定參數，那麼在呼叫使用的時候，就要傳入相對應的引數。 也可以省略 @include 這幾個字，直接用 + 代替 @content 強化 mixin 功能 適用時機：用於傳遞內容至 mixin 例如使用在斷點時： 123@mixin breakpoint($width) @media screen and (min-width: $width) @content 12345.btn +breakpoint($breakpoint-tablet) color: blue +breakpoint($breakpoint-desktop) color: red 1234567891011@media screen and (min-width: 768px) { .btn { color: blue; }}@media screen and (min-width: 1024px) { .btn { color: red; }} function 管理屬性 可以回傳數值 使用前要先宣告 12@function letter-spacing($font-index) @return $font-index / 10 * 0.2rem 也能搭配 @mixin 一起使用 1234@mixin hover-btn($color, $font-index) &amp;hover background: $color letter-spacing: letter-spacing($font-index) extend + mixin + function 綜合應用12345678910.btn &amp;-primary @extend %btn +hover-btn($primary, 2) &amp;-secondary @extend %btn +hover-btn($secondary, 3) &amp;-warning @extend %btn +hover-btn($warning, 100) 編譯後 123456789101112.btn-primary:hover { background: #000000; letter-spacing: 0.04rem;}.btn-secondary:hover { background: #eeeeee; letter-spacing: 0.06rem;}.btn-warning:hover { background: red; letter-spacing: 2rem;} Sass 自動化Map &amp; List參考：你可能不知道的 Sass 技巧 condition 與 loop 參考資料： 新手也可以輕鬆玩轉 SASS - @mixin and @include SCSS 筆記(2) - extend、mixin、function Sass 教學 (11) - @content","link":"/Front-End/CSS-%E9%A0%90%E8%99%95%E7%90%86%E5%99%A8-SASS-%E5%9F%BA%E6%9C%AC%E8%AA%9E%E6%B3%95%E4%BB%8B%E7%B4%B9/"},{"title":"Command Line 與 Vim 基本操作","text":"Command Line 簡單來說就是和電腦溝通的語言，而我們操作電腦的方式一般來說有兩種： 圖形使用者介面（GUI） 命令列介面（CLI） 圖形使用者介面（GUI）全名是 Graphical User Interface，是指用圖形方式顯示的電腦操作用戶介面，也是我們平常最常用來操作電腦的方式。若用更白話、簡單的方式來說，就像下圖一樣，我們要新增資料夾時，可以透過滑鼠點擊的方式來操作。 命令列介面（CLI）全名是 Command-Line Interface，是在 GUI 普及之前最廣泛運用的使用者介面，通常不支援滑鼠，而是利用鍵盤來輸入指令，電腦接收到指令後，將會執行。 CLI 學習理由對設計師、剪輯師或其他職業來說，都能使用有 GUI 的軟體來工作，但在程式開發裡，有很多工具不提供圖形介面，只能透過指令來和電腦溝通。 結論：工程師必備技能。（想想看，你有看過電影裡有哪個駭客還在慢慢用 GUI 的嗎？感覺就弱掉了對吧。） Command Line 常用指令基本指令懶人包 指令 英文縮寫來源 說明 pwd print working directory 顯示目前所在位置 ls list 列出目前資料夾底下的所有檔案 ls-al list all 列出詳細資料，包含檔案大小、修改時間、隱藏檔案… cd change directory 切換資料夾 cd .. 回到上一層資料夾 clear clear 清空終端機畫面 man manual 使用說明書 印出所在位置pwd：顯示目前所在位置（print working directory） 列出檔案清單ls：列出目前資料夾底下的所有檔案（list） ls-al：列出詳細資料在ls 後面加上參數 -al ，會列出詳細資料，例如：檔案權限、檔案擁有者、檔案大小、最後修改時間、所有隱藏檔案。 切換資料夾cd：切換資料夾（change directory） cd ..：如果在cd 後面加上 .. 的話，則能夠回到上一層資料夾 clear：清空終端機畫面，想要清空畫面的時候可以輸入這個指令。（超方便！之前不知道這個指令卻又有強迫症想清空畫面，都用很笨的方法關掉再重開終端機。） man：使用說明書（manual）舉例：輸入 man ls 後，會列出 ls 的詳細用法。 檔案操作相關指令懶人包 指令 英文縮寫來源 說明 touch 建立檔案或更改檔案時間 rm remove 刪除檔案 rmdir 資料夾名稱 remove directory 刪除資料夾 rm -r 資料夾名稱 刪除資料夾（慎用！） rm -f 刪除資料夾（超危險！） mkdir make directory 建立資料夾 mv move 移動檔案或改名 cp copy 複製檔案 date date 顯示當前時間 top table of processes 顯示所有 Process cat catenate 連接檔案或把檔案內容顯示出來 less 分頁印出檔案 echo 印出字串 建立檔案或更改檔案時間touch：建立檔案或更改檔案時間。當檔案「存在」時，輸入 touch 後，檔案修改時間將會更新。 當檔案「不存在」時，輸入 touch 後，將會新增檔案。 刪除檔案rm：remove，只要輸入 rm 檔案名稱，即可刪除檔案。 這裡記得需輸入檔案格式，如：.txt、.jpg⋯等。 rm 只能刪除檔案，如果想刪除資料夾的話有幾種作法： rmdir 資料夾名稱：remove directory，在 rm 後面加上dir rm -r 資料夾名稱：在 rm 後面加上空格+-r 若檔案本身沒有保護機制，使用 rm -r 指令會直接刪除資料夾及裡面的所有檔案。（慎用！） rm -f 即使檔案有保護機制會跳出確認訊息時，使用 rm -f 指令一樣會無視保護機制，直接刪除檔案。（超危險！） 建立資料夾mkdir：make directory，輸入 mkdir 資料夾名稱，即可建立資料夾。 移動檔案或改名mv：move，用於移動檔案或改名。 移動檔案： 更改檔案名稱： 複製檔案cp：copy，複製檔案。 指令：cp + 原本檔案名稱 + 新複製的檔案名稱範例： cp test.txt test2.txt 如果要複製「資料夾」的話，要加上 -r。指令：cp + -r + 原資料夾名稱 + 複製的資料夾名稱 顯示當前時間date：顯示當前時間。 顯示所有 Processtop：table of processes，顯示所有 Process。 連接檔案或把檔案內容顯示出來cat：catenate，連接檔案或把檔案內容顯示出來。 例如：輸入 cat jquery.js，終端機即會顯示jquery.js 裡面所有內容 分頁印出檔案less：分頁印出檔案。 因為使用 cat 指令顯示出的檔案內容可能會太佔據終端機版面，可以使用這個指令進入閱讀模式，並可按 :q 退出模式，也不會佔據到終端機版面 印出字串echo：印出字串。 Command Line 其他好用指令抓取關鍵字grep：抓取關鍵字。 指令：grep + 關鍵字 + 檔案名稱 使用情境示範：有一個 hello.txt 的文字檔案，內含許多文字，今天我要找出關鍵字 oh 的話，該怎麼做呢？ 輸入：grep + oh + hello.txt，即會顯示出擁有 oh 這個關鍵字的所有字句。 下載檔案wget：下載檔案，非內建指令，需要先安裝。 指令：wget + 想要下載的圖片網址或檔案網址 送出 requestcurl：送出 request。 指令組合技串接指令pipe:|：串接指令，可以把前面的輸出變成後面的輸入。 例如：cat file.txt | grep hi把前面使用 cat 印出的檔案內容，用 grep 抓取關鍵字出來 重新導向redirect: &gt;：重新導向redirection： 重新導向 input output （寫給自己看：這部分有空再回去看 [CS101] 2-4） Vim 文字編輯器Vim 是一款歷史悠久，並由 Vi 發展出來的文字編輯器，也是 Git 預設的編輯器。雖然目前已有許多文字編輯器能夠使用，例如：VS Code、Sublime Text 等，但很多人在使用 Git 過程中，可能會不小心進入這個編輯器，而這個編輯器的使用方式相較其他文字編輯器來說比較特別，需要透過特定指令才能達到輸入文字、存檔，甚至是離開的動作。 Vim 的基本操作 常用模式Vim 至少有超過五種以上的模式能夠應用，這邊只簡單介紹三種最常使用的模式： 普通模式（預設模式）：無法打字的狀態 插入模式：可輸入文字，按 ESC 鍵可回普通模式 命令行模式：可輸入以下所提到的常用指令使用 常用指令 :q：不存檔，直接離開 :q!：不存檔，強制離開（當有修改不想儲存時） :w：存檔，但不離開 :!w：強制存檔，但不離開 :w {name}：存檔並命名為 name，但不離開 :wq：存檔並離開 :!wq：強制存檔並離開 其他未提及的指令及模式可自行查閱。 參考資料： Huli－紮實的網頁前端學習路線與資源推薦 維基百科：Vim 超簡明 Vim 操作介紹 簡明 Vim 文字編輯器操作入門教學","link":"/Others/Command%20Line%20%E8%88%87%20Vim%20%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"},{"title":"CSS Selector 權重的計算方式","text":"在談論 CSS Selector 權重的「計算方式」之前，我們先來了解 CSS Selector 的優先權。 在優先權規則中，從高至低排列分別為： Animation（動畫執行期間）&gt; !important &gt; inline style &gt; ID &gt; Class 與屬性選取器 &gt; 元素選擇器 &gt; ＊通用選取器 &gt; 繼承的屬性 CSS Selector 的類型1. Animation（動畫執行期間）關鍵影格（@keyframes）中的 CSS 屬性在「動畫執行期間」擁有絕對的優先權。 2. !important!important 是 CSS 中的特殊規則，只要在 CSS 屬性後面接上「!important」，將會變成極高的優先權，是人人懼怕的大魔王。 1&lt;p class=\"title\"&gt;Hello&lt;/p&gt; 12345678p { color: red !important; font-size: 20px;}.title { color: blue; font-size: 16px;} 原本 Class 選取器 .title 優先於元素 &lt;p&gt;，一旦在屬性加上 !important 後，最後 Hello 字體呈現的結果會變成： 12color: red !important; /* &lt;p&gt; !important 強制優先權 */font-size: 16px; /* .title 賦予的屬性 */ 3. 行內樣式（inline style）利用 HTML 元素中的 style 屬性將 CSS 樣式寫入，就稱為行內樣式（inline style）。 1&lt;p style=\"color: red;\"&gt;Hello&lt;/p&gt; 4. ID 選擇器 #id5. 類別選擇器.class 與屬性選取器 [attr=value]Class 選擇器值得一提的是，偽類別 (pseudo-class) ，是由單一一個「:」冒號作為開頭的選取器，本身也是 Class 選擇器的其中之一，讓人容易與「::」作為開頭的偽元素 (pseudo-element) 混淆。 偽類別：:hover、:nth-child…偽元素：::before、::after、::placeholder… 6. 元素選擇器例如：&lt;p&gt;、&lt;head&gt;、&lt;div&gt; … 7. ＊通用選取器全域選擇器以星號 * 代表，適用於所有元素 8. 繼承的屬性如以下範例，雖然 &lt;p&gt; 沒有設定文字色彩屬性，但因為 &lt;p&gt; 寫在 &lt;div&gt; 當中，故 &lt;p&gt; 會繼承父層 &lt;div&gt; 的文字屬性。 123&lt;div&gt; &lt;p&gt;內文&lt;/p&gt;&lt;/div&gt; 123div { color: red;} CSS Selector 的計算方式 計算值 ID 選擇器 = a Class 選擇器、屬性選取器、偽類別 = b 元素選擇器、偽元素 = c 計算方式先比較 a 的數量，其次比較 b 的數量，最後比較 c 的數量 範例 選擇器 權重值 順位 #nav &gt; li.active::before a = 1, b = 1, c = 2 第一 #nav li.active a = 1, b = 1, c = 1 第二 div .card.active:hover::before a = 0, b = 3, c = 2 第三 ul &gt; li:hover a = 0, b = 1, c = 2 第四 如果想知道自己對於 CSS Selector 的優先權及計算方式的觀念是否正確，非常推薦到 Specificity Calculator 這個網站測試看看。 參考： 關於 Webpack，它是什麼？能夠做什麼？為什麼？怎麼做？ Gulp 与 WebPack 有区别吗？如果有，有什么区别？ 《金魚都能懂的 CSS 選取器：金魚都能懂了你還怕學不會嗎》書籍內容 CSS3 Selectors Specificity","link":"/Front-End/CSS-Selector-%E6%AC%8A%E9%87%8D%E7%9A%84%E8%A8%88%E7%AE%97%E6%96%B9%E5%BC%8F/"},{"title":"JavaScript - == 與 === 的差別","text":"在提 == 和 === 的差別前，先看這段程式碼： 12let a = 10console.log(a = 1) // 印出 1 以這段程式碼來說，程式解讀的順序會是 先跑 a = 1 &gt; 再跑 console.log(a) &gt; 所以最後 console.log 會得到 1 那如果是這段程式碼： 12let a = 10 == 10console.log(a) // 印出 true 因為程式會先從右邊執行到左邊，10 == 10 為 true，所以 a = true。為了程式碼可讀性，建議先用括弧框起來，例如：let a = (10 == 10) == 與 === 的差別==（一般相等）：會轉換型態，== 會先將值轉換成同個型態再做比較，用來寫程式容易有 bug。===（嚴格相等）：不會轉換型態，除了值以外，型態也一定要相同，否則會被視為不相等。 （強烈建議開發時使用 === 來寫） 1234560 == '0' // true，因為型態已被轉換過0 === '0' // false，型態不同0 == '' // true0 === '' // false2 == '2' // true，因為型態已被轉換過2 === '2' // false，型態不同 object 物件 1234567let obj = { number: 1}let obj2 = objobj.number = 2console.log(obj === obj2) // 印出 true，因為比較的是記憶體位置 array 陣列 12345678910111213141516171819let arr = []let arr2 = []console.log(arr === arr2) // 印出 false，因為比較的是記憶體位置let arr = [1]let arr2 = [1]console.log(arr === arr2) // 印出 false，因為比較的是記憶體位置---let arr = [1]let arr2 = [1]arr2 = arr // 賦值console.log(arr === arr2) // 印出 true---// 同上述理論console.log([] === []) // 印出 falseconsole.log({} === {}) // 印出 false 推薦網站：JS Comparison Table，裡面列出 == 與 === 對照的值。 等號判斷的 Edge Case：NaN NaN 的介紹可以參考此篇：NaN 是什麼 NaN 在等號判斷有個 Edge Case，無法解釋，可以當作特殊規則來記。 123456789let a = Number('hello')console.log(a === a) // 印出 false// 其原理是因為 NaN 連自身都不等於 NaNconsole.log(NaN === NaN) // 印出 false// 如果在不是 NaN 的狀況就會正常，例如：let a = 1console.log(a === a) // 印出 true","link":"/Front-End/JavaScript%20-%20==%20%E8%88%87%20===%20%E7%9A%84%E5%B7%AE%E5%88%A5/"},{"title":"JavaScript - ES6 類別（Class）","text":"JavaScript 在 ES6 之前，通常使用建構子函式來定義物件與功能，ES6 以後開始引入 class 語法糖可以使用。 語法糖指電腦語言中添加的某種語法，這種語法對語言的功能沒有影響，但是更方便程式設計師使用。語法糖能讓程式更加簡潔，有更高的可讀性。 ES5 vs ES6以下示範得到同樣結果時，使用 ES5 和 ES6 語法的差別。 ES5 建構函式搭配 prototype12345678910111213141516171819// 這個函式的功用等於下面 ES6 範例的 constructor 函式function Dog(name) { this.name = name}Dog.prototype.getName = function() { // 為了共享內容，所以需使用 prototype return this.name}Dog.prototype.sayHello = function() { // 為了共享內容，所以需使用 prototype console.log(this.name)}var d = new Dog('Hey')d.sayHello()var a = new Dog('Hi')a.sayHello()console.log(d.sayHello === a.sayHello) // true ES6 Class1234567891011121314151617class Dog { constructor(name) { this.name = name } getName() { return this.name } sayHello() { console.log(this.name) }}var d = new Dog('Hey')d.sayHello()var a = new Dog('Hi')a.sayHello() ES6：類別（class）類別（class）可以簡單想像成一張設計圖，裡面定義各種資料、行為。定義類別（class）的方法有兩種： 類別宣告 類別敘述 類別宣告使用類別宣告來定義類別的宣告方法：關鍵字 class + 類別名稱。 注意：名稱命名慣例為首字母大寫，方便在程式碼中辨識。 123456class Dog { // class（關鍵字） + Dog（類別名稱） constructor(name) { this.name = name }}const dog = new Dog('Lucky') 類別宣告不同於函數宣告，需要先宣告類別，才能存取，否則會出現 ReferenceError。 12345678// 類別宣告var d = new Dog()class Dog { ... }//ReferenceError: Dog is not defined// 函數宣告會 Hoistingdog()function dog() { ... } 類別描述另一種定義類別方法是類別敘述，有無名稱都可以。（注意：類別敘述跟類別宣告一樣，都會受到 Hoisting 的影響。） 12345678910111213// 無名稱var Dog = class { constructor(name) { this.name = name }}// 有名稱var Dog = class Dog { constructor(name) { this.name = name }} Class 實際應用12345678910class Dog { constructor(name) { this.name = name // this 的值指的就是「誰」在呼叫 } sayHello() { console.log(this.name, ' Hello') // this 的值指的就是「誰」在呼叫 }}const lucky = new Dog('Lucky')lucky.sayHello() // lucky 呼叫，所以此處的 lucky 就是 this 參考資料： MDN - Classes [ES6 JavaScript] 類別 (Class) 與 建構式 (Constructor) 物件導向基礎與 prototype 複習請看： 該來理解 JavaScript 的原型鍊了 [week 16] JavaScript 進階 - 物件導向 &amp; Prototype","link":"/Front-End/JavaScript%20-%20ES6%20%E9%A1%9E%E5%88%A5%EF%BC%88Class%EF%BC%89/"},{"title":"JavaScript - Fetch/Promise/Async/Await","text":"在學習 ES6 以前，發出請求就需要藉由 XMLHttpRequest() 的方式執行，但現在已經有操作更直覺方便的方法了，那就是：Fetch。 Fetch 基本介紹 可取代傳統的 XMLHttpRequest Fetch 是 ES6 的新語法 可以接收跨站的 cookies，能用 Fetch 來建立跨站的 session 不會傳送 cookies，除非有額外設定 如果請求得到回應，回傳的是帶有 Response 的 Promise 物件 傳統的 XMLHttpRequest 範例： 12345678910111213141516const API_URL = 'https://exsample.com/example/1';const request = new XMLHttpRequest(); // 定義 Http requestrequest.open('GET', API_URL); // 定義方法（GET：讀取資料／POST：傳送資料至伺服器）// 當請求完成，則開始執行以下函式request.onload = function() { if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) { // 成功就列出結果 console.log(request.response); } else { // 失敗處理 }};request.send(); // 送出請求 Fetch 基本用法1234567fetch('http://example.com/movies.json') // 使用 fetch() 發出 request .then(function(response) { // 利用 then() 取得 response return response.json(); // 需透過 json()、text() 轉成可以使用的資訊 }) .then(function(myJson) { console.log(myJson); // 得到的 json }); then() 的規則是裡面要放入 function Fetch 的 Request 設定值Fetch 常用的 Request 屬性包含： 屬性 設定值 body 要加到要求中的內容（如果 method 為 GET 或 HEAD 則不設定） url 第一個參數，一定要填的項目，代表需要 fetch 對象的網址 method GET、POST、PUT、DELETE、HEAD（預設 GET） headers 要求相關的 Headers 物件（預設 {}） mode ors、no-cors、same-origin、navigate（預設 cors） referrer no-referrer、client 或某個網址（預設 client） credentials omit、same-origin、include（預設 omit） redirect default、no-store、reload、no-cache、force-cache（預設 default） cache 第一個參數，一定要填的項目，代表需要 fetch 對象的網址 表格取自 JavaScript Fetch API 使用教學 實戰 Fetch 加入 Request 設定值（以帶入 header 和 method 為範例）123456789101112fetch('https://exsample.com/example/', { body: JSON.stringify(data), // must match 'Content-Type' header headers: { 'user-agent': 'Mozilla/4.0 MDN Example', 'content-type': 'application/json' }, method: 'POST', // 若沒有寫 method 就是默認 GET }) .then(response =&gt; response.json()) // 需透過 json()、text() 轉成可以使用的資訊 .then(data =&gt; { return callback(data) }) Fetch 的 Response 方法以下僅列出幾種 Fetch 常用的 Response 方法，更多方法請參考 fetch Response json() text() blob() … Promise 是什麼？Promise 本身是一個建構函式，是用來優化處理非同步行為的語法。 一般來說，處理非同步事件，除了使用 CallBack 以外，也能使用 Promise 來處理，且 Promise 的可讀性與後續維護都優於 CallBack。 Promise 的狀態當拿到 Promise（承諾） 時，會有幾種狀態發生： Pending，得不到回應（事件運行中，尚未取得結果） Resolve，承諾實現（事件執行完畢且成功操作） Reject，承諾被拒絕（事件執行完畢卻操作失敗） 就算是 Resolve 或 Reject 狀態，也必定會經過 Pending 製作自己的 PromisePromise 程式碼懶人包一個基本的 Promise 長這樣： 12345678const newPromise = new Promise((resolve, reject) =&gt; { resolve(status) // 成功時回傳 reject(status) // 失敗時回傳}).then((data) =&gt; { // 用 then 來做行為成功的處理}).catch((error) =&gt; { // 用 catch 來做失敗的處理}) 開始製作首先類似物件導向，Promise 需要先 new 出物件才能使用原型方法（then()、catch()、finally()） 12345function init(resolve, reject) { resolve(status) // 成功時回傳 reject(status) // 失敗時回傳}const myPromise = new Promise(init); 函式內傳入的 resolve 跟 reject 也是函式 resolve 是執行成功後會執行的函式；reject 則是失敗後所執行的函式 resolve 及 reject 可以自定名稱，但大多數開發者習慣維持此名稱 實際測試Promise 可以使用 then() 取得成功的結果；使用 catch() 取得成功或失敗的結果 123456789101112131415function init(resolve, reject) { resolve(3) reject(4)}const myPromise = new Promise(init);myPromise.then((data) =&gt; { console.log('data', data)}).catch((err) =&gt; { console.log('error', err) // 用 catch 來做失敗的處理})// 實測後將得到 data3 特別要注意的是，resolve() 及 reject() 互相衝突，就算兩者同時寫，也只會跑入 .then() 或 .catch() 其中之一的函式，並不會兩者都執行 簡化程式碼上述程式碼進行簡化，簡化方式為直接將 init funtion 放進 new Promise，並改成箭頭函式 1234567891011const myPromise = new Promise((resolve, reject) =&gt; { resolve(3) reject(4)});myPromise.then((data) =&gt; { console.log('data', data)}).catch((err) =&gt; { console.log('error', err) // 用 catch 來做失敗的處理}) 達成最終目標根據上述程式碼，即可完成自製 Promise 123myPromise.then(() =&gt; {}) 其他補充使用 fetch() 會得到 =&gt; Promiseresponse.text() 也是得到 =&gt; Promiseresponse.json() 也是得到 =&gt; Promise Promise 本身是一個建構函式 Async、Await 是什麼？Async、Await 需搭配 Promise 語法使用，能寫出類似同步行為的程式碼，而實際上仍是非同步的語法，使程式碼更直覺易讀。 用法：在 function 前面加入 async，在非同步的 Promise 函數前面加上 await 版本對照範例一Promise 版本 123456function mainPromise() { console.log('enter main') sleep(1000).then(() =&gt; { console.log('exit main') })} Async、Await 版本 12345async function main() { console.log('enter main') await sleep(1000) console.log('exit main')} 使用 Async、Await 以後，也能搭配 try...catch 語法來做錯誤處理 1234567891011async function main() { console.log('enter main') await sleep(1000) try { const result = await getData() } catch(err) { console.log('錯誤：' + err) } console.log('result')} 範例二Promise 版本 123456789function getStreams(gameName) { return fetch('http://example.com/movies.json', { headers: { 'Accept': 'application/example', 'Client-ID': 'XXXX' } }) // 沒有寫 method 就是默認 GET .then(response =&gt; response.json()) // 這邊 return 的是用 then() 以後得到的一個 promise} Async、Await 版本 123456789async function getStreams(gameName) { const response = await fetch('http://example.com/movies.json', { headers: { 'Accept': 'application/example', 'Client-ID': 'XXXX' } }) // 沒有寫 method 就是默認 GET return await response.json()} 重點補充 有 Promise 就不會有 callback，除非用的 library 不支援 用了 async/await，通常就不會有 .then 跟 .catch 了 參考資料： MDN - Fetch JavaScript Fetch API 使用教學 JavaScript Promise 全介紹","link":"/Front-End/JavaScript%20-%20Fetch-Promise-Async-Await/"},{"title":"JavaScript - this","text":"在不是物件導向的環境下，this 的預設值會是 global，依據不同環境呼叫 this，所得到的值也會不同。 例如：在 node.js 裡面呼叫預設值會是 global 的東西，在瀏覽器上則會得到 windows 的東西。 12345function test() { console.log(tihs);}test(); // 根據環境所得到的值會不同 是不是聽起來覺得很奇怪？ this 的值為什麼不是我們想要的值？這時候只要加上 'use strict';，就會開啟嚴格模式。 123456\"use strict\";function test() { console.log(tihs);}test(); // undefined call() 與 apply()除了使用 func() 來呼叫 function 外，call() 和 apply() 可以做為呼叫 function 的其他兩種方式。 call()123fun.call(thisArg[, arg1[, arg2[, ...]]])// thisArg：呼叫 fun 時提供的 this 值。// arg1, arg2, ...：其他參數。 範例： 123456789'use strict';function test() { console.log(this)}test.call(123) // 123 test.call({}) // {} test.call([1]) // [1] call() 裡面的值是什麼，this 就是什麼。 apply()1234fun.apply(thisArg, [argsArray])// thisArg：讓 fun 呼叫時可以視為 this 的值。// argsArray：一個 array-like object ，定義了 fun 要呼叫的一組參數，如果沒有需要提供，可以傳入 null 或 undefined。 兩者的差別call() 呼叫 function 時可以使用多個參數。apply() 與 call() 不同，apply() 只放兩個參數，第二個參數是陣列。 共同之處兩者的第一個參數，都可以改變 this 的值。 範例： 123456789101112'use strict';function test(a, b, c) { console.log(this) console.log(a, b, c)}test.call(123, 1, 2, 3)test.apply(123, [1, 2, 3])// 答案一樣都是：// 123// 1 2 3 呼叫的方式this 的值與什麼時候被定義無關，與呼叫的方式才有關係。this 代表的是 function 執行時所屬的物件，而不是 function 本身。 範例一： 123456789101112\"use strict\";const obj = { a: 123, test: function () { console.log(tihs); },};obj.test();// { a: 123, test: [function: test] }// 得到 obj 本身 範例二： 1234567891011\"use strict\";const obj = { a: 123, test: function () { console.log(tihs); },};var func = obj.test;func(); // undefined 用不同角度看 this 的值 把呼叫的 function 前面的東西放進 call() 裡面。用這樣的方式可以快速理解 this 的值是什麼。 範例一： 123456789101112\"use strict\";const obj = { a: 123, test: function () { console.log(tihs); },};obj.test()// { a: 123, test: [function: test] }// 得到 obj 本身 obj.test() 可以看成 obj.test.call(obj) 範例二： 12345678910\"use strict\";const obj = { a: 123, inner: function () { console.log(tihs); },};obj.inner.test() // { test: [Finction: test] } obj.inner.test() 可以看成 obj.inner.test.call(obj.inner) 範例三： 1234567891011\"use strict\";const obj = { a: 123, inner: function () { console.log(tihs); },};const func = obj.inner.testfunc() // undefined 因為 func() 前面已經沒有東西可以放進 call() 了，所以可以看成 func.call(undefined) 特例：箭頭函式裡的 this上述有提到 this 與呼叫的方式有關係，但箭頭函式卻是特例！箭頭函式裡面的 this 和怎麼呼叫無關，和在哪裡定義有關。 參考資料： What’s THIS in JavaScript ? [上]","link":"/Front-End/JavaScript%20-%20this/"},{"title":"JavaScript - 什麼是閉包 Closure？","text":"學習 JavaScript 時，我們時常會聽到閉包這個名詞，究竟什麼是閉包呢？ 直接來看範例吧！首先這是沒有閉包的程式碼： 123456789101112function test() { var a = 10 function inner() { a++ console.log(a) } inner()}test() // 回傳 11test() // 回傳 11test() // 回傳 11 接著改成閉包的方式，從外面去呼叫 inner()test() 裡面不要直接呼叫 inner()，把它改成 return inner（回傳 function） 12345678910111213function test() { var a = 10 function inner() { a++ console.log(a) } return inner // 回傳 function}var func = test() // 改成有個東西來接 function =&gt; 換句話說 var func = innerfunc() // 這句等於在呼叫 inner()，回傳 11func() // 回傳 12func() // 回傳 13 上述程式碼 return inner 的部分可以再做簡化： 123456789101112function test() { var a = 10 return function () { a++ console.log(a) } // 回傳 function}var func = test() // 改成有個東西來接 function =&gt; 換句話說 var func = 回傳的 functionfunc() // 這句等於在呼叫回傳的 function，回傳 11func() // 回傳 12func() // 回傳 13 從上述範例中可以理解：閉包就是在一個 function 裡面 return function一般而言只要函式執行完成後，函式裡面的資源就會被釋放掉，但在閉包的情況下，變數的值卻可以被保存！ 其他例子： 1234567891011121314151617181920212223242526272829303132333435function complex(num) { // 複雜計算的函式 console.log('calculate'); // 藉由此行得知有沒有經過計算 return num * num * num;}function cache(func) { var ans = {}; // 先宣告答案是空物件 return function(num) { // 如上述提及的可以簡化語法，所以這邊直接 return function if (ans[num]) { return ans[num]; } ans[num] = func(num); // 在這裡等同於 ans[20] = complex(20) return ans[num]; }}const cachedComplex = cache(complex)// 上面這句可以拆解成：// cachedComplex = return function(num) {// if (ans[num]) { 如果是已經被計算過，就直接輸出結果// return ans[num];// } // ans[num] = complex(num); 如果沒有被計算，就進入 complex(num) 計算// return ans[num]; 最後輸出計算完的結果// }console.log(cachedComplex(20)) // 計算 =&gt; 函式執行後，ans[20] = complex(20)，因為閉包的關係，ans = { [20] } 會被保存給後面的程式碼做使用// calculate// 8000console.log(cachedComplex(20)) // 純輸出 =&gt; 此時進入 if 判斷 ans[20]// 8000console.log(cachedComplex(20)) // 純輸出// 8000 先紀錄一下自己學習時受用的文章（複習時可看）： 前端中階：JS令人搞不懂的地方-Closure(閉包) [第十七週] JavaScript 進階：什麼是閉包 Closure 與實際應用 [第十七週] JavaScript 進階：從作用域鍊 ScopeChain 來理解 Closure 原理 從 ECMAScript 看作用域10.1.4：每一個 EC 都有 scope chain，當進入 EC 時，scope chain 就會被建立 10.1.6：進入函式後，AO（Activation Object，執行物件）會被新增，且會有個預設的屬性為 arguments，這時 AO 即可被當成 VO 來使用AO 與 VO 的功能差不多，最大差別在於：在 global 的執行環境時是 VO，在函式的執行環境時則是 AO。 10.2：當進入一個 EC ，scope chain 就會被建立與初始化，變數也被初始化 10.2.3：進入函式後，scope chain 會被初始化成：[AO, [[Scope]]]，[[scope]] 屬性放的是父層 scopeChain 的值 1234567891011121314151617innerEC: { AO: { b: undefined, function: function, }, scopeChain: [function EC.AO, globalEC.VO]}globalEC: { VO: { a: undefined, inner: function, }, scopeChain: [globalEC.VO]}inner.[[scope]] = [globalEC.VO] // inner function 的父層是 global，所以 inner 的 [[scope]] 就是 global 的 scopeChain 的值","link":"/Front-End/JavaScript%20-%20%E4%BB%80%E9%BA%BC%E6%98%AF%E9%96%89%E5%8C%85%20Closure%EF%BC%9F/"},{"title":"JavaScript - 宣告變數的方式與作用域（Scope）","text":"早期宣告變數都使用 var 來宣告，但自從 ES6 出現後，多了兩個新選擇：const（宣告常數）及 let（宣告變數）。 常數 const（constant） 變數 var（variable） let ES6 後才出現的 let 和 ES6 之前的 var 有什麼差別呢？ var 與 let、const 最大的差別就是 作用域（Scope）的定義不同。var 的作用域範圍是 Function Scope。let 或 const 的作用域範圍是 Block Scope，所謂的 Block Scope 就是變數的作用範圍只存在兩個大括號 { } 中。 作用域 說明 var Function Scope function { } let 與 const Block Scope { } （給自己看：有空再補圖解） 常數 constconst（constant）是常數，值是不能改變的，且一定要先給初始值，不可事後才給 1234// 值是不能改變的const b = 20b = 30// 會有錯誤提示 TypeError: Assignment to constant variable 1234// 一定要先給初始值，不可事後才給const bb = 30// 會有錯誤提示 SyntaxError: Missing initializer in const declaration 123456789101112const obj = { number: 1}obj.number = 2// 不會有錯誤提示，因為記憶體位置一樣const obj2 = { number: 1}obj2 = { number: 2 }// 會有錯誤提示 TypeError: Assignment to constant variable// 記憶體位置改變，代表值也換了 關於記憶體位置，可以參考之前寫的 JavaScript - 變數與賦值 其中 Object 的內容 變數 var 與 let目前宣告變數的方式有兩種，var（variable）以及 let，兩者最大的差別是Scope（作用域） 什麼是 Scope（作用域）？作用域簡單來說是變數的生存範圍 先談 ES6 以前的作用域在 ES6 出現前只能使用 var 來宣告，其作用範圍是 Function Scope，只有 function 可以產生新的作用域。這是什麼意思呢？來看看範例： 123456function test() { var a = 10 console.log(a)}test() // 印出 10console.log(a) // 會出現 ReferenceError: a is not defined 因為 a 宣告在 function 裡面，a 只有在這個函式裡面，才能被大家看見，所以一旦離開函式，就會找不到 a 的變數宣告。 問題：如果變數宣告在外面呢？ 變數宣告在外面的話即是 global variable 全域變數，代表所有人都看得見它。而作用域的特性是從內層開始往外層找，當在 test() 裡面找不到 a 的宣告時，就會往上一層找，便能找到全域變數的 a，所以 console.log(a) 就能順利顯示。 123456var a = 10function test() { console.log(a)}test() // 印出 10console.log(a) // 印出 10 其他範例： 1234567var a = 20function test() { var a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 20 特別要注意的範例這段程式碼的執行順序：執行 test() &gt; 找到 test function &gt; 函式裡面沒有宣告 a&gt; 往外找到 var a = 20 並帶入函式 &gt; 用賦值去改變 a &gt; 所以 a 已經被改變成 10 1234567var a = 20function test() { a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 10 如果沒有宣告變數，JavaScript 會自動把 a 轉成全域變數，但這樣容易出現 bug，不建議這樣做 123456function test() { a = 10 console.log(a)}test() // 印出 10console.log(a) // 印出 10 Scope chain（範圍鏈）就是指變數從最裡面往外找的行為 1234567891011121314151617var a = 'global'function test() { var a = 'test scope a' var b = 'test scope b' console.log(a, b) function inner() { var b = 'inner scope b' console.log(a, b) } inner()}test()console.log(a)// 印出：// test scope a test scope b// test scope a inner scope b// global Scope（作用域）容易把和其他觀念混淆之處： 1234567891011var a = 'global' // global scopefunction change() { // change scope var a = 10 test()}function test() { // test scope console.log(a)}change() // 最後會印出 global 關於 test() 的範圍鏈： 初學者以為的是 test scope -&gt; change scope -&gt; global scope （錯誤） 正確的範圍鏈是 test scope -&gt; global scope change() 和 test() 是平行世界， 在哪裡呼叫沒有關係 ES6 出現後的作用域以下使用 var 為範例： 12345678function test() { var a = 60 if (a === 60) { var b = 10 } console.log(b)}test() // 印出 10 接下來改以 let 宣告測試：因為 b 只存在 if (a === 60) { } 的判斷式裡面，所以在外面的 console.log(b) 就找不到 b 12345678function test() { var a = 60 if (a === 60) { let b = 10 } console.log(b)}test() // 會有錯誤提示 ReferenceError: b is not defined 其他範例：當 i 變成 3 時，就不符合條件而跳出迴圈，所以最外面的 final value 即會得到 3 123456789101112function test() { for (var i = 0; i &lt; 3; i++) { console.log('i:', i) } console.log('final value:', i)}test()// 印出：// i: 0// i: 1// i: 2// final value: 3 如果改成 let，因為 i 只存在 for 迴圈裡面，一跳出迴圈就會變成未定義的變數： 123456789101112function test() { for (let i = 0; i &lt; 3; i++) { console.log('i:', i) } console.log('final value:', i)}test()// 印出：// i: 0// i: 1// i: 2// ReferenceError: b is not defined","link":"/Front-End/JavaScript%20-%20%E5%AE%A3%E5%91%8A%E8%AE%8A%E6%95%B8%E7%9A%84%E6%96%B9%E5%BC%8F%E8%88%87%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89/"},{"title":"JavaScript - 淺談 Hoisting","text":"之前在 《JavaScript - 宣告變數的方式與作用域（Scope）》 中提到變數有作用域的特性，這次則要來認識 Hoisting（提升）。 目錄 什麼是 Hoisting？ Hoisting 的順序 Function 佔有優先權 Hoisting 好文推薦 let 與 const 的詭異行為 let 提升的方式 什麼是 Hoisting？Hoisting 可以想像成把 變數 或 function 的宣告移動到程式碼區塊頂端的一種現象，但如果深入去理解 Hoisting 的話，會發現其實也不是那麼「簡單」。 在 JavaScript 裡面，在還沒有宣告前就呼叫變數，會得到 a is not defined。（關於 not defined 的解釋可以參考 這篇） 1console.log(a) // ReferenceError: b is not defined 那如果先使用變數才做宣告呢？ 12console.log(a) // 回傳 undefinedvar a = 10 undefined 會出現的狀況是「已宣告卻尚未給值」，按照程式碼的邏輯是由上往下執行才對，為什麼先呼叫變數後才開始宣告，會出現 undefined 呢？ 像上述狀況，變數的宣告被「提升」到最上面這樣的現象就稱為 Hoisting（提升）。（這邊可以先注意一件事：只有宣告會提升，賦值不會提升。） Hoisting 的特性除了變數宣告會提升以外，函式宣告也是會提升的喔！所以我們可以在宣告函式前就先呼叫函式，最顯而易見的範例： 12345test() // 先呼叫 test() function test() { // 才宣告 test 函式 console.log(123)}// 執行結果為 123 如果改成函式表達式呢？竟然會回報 test is not a function！ 12345test()var test = function() { console.log(123)}// 執行結果為 TypeError: test is not a function 這是因為只有宣告會提升，賦值不會提升。所以我們可以想像提升後，其實是像這樣： 123456var testtest()test = function() { console.log(123)} Hoisting 只會發生在自身作用域1234567var a = 'global'function test() { console.log(a) var a = 'local'}test() // 回傳 undefined 為什麼會回傳 undefined 呢？原理就是 Hoisting 只會發生在自身作用域，以及宣告會提升，賦值不會這兩件事，所以程式碼可以想像成這樣： 12345678var a = 'global'function test() { var a // 宣告提升 console.log(a) a = 'local' // 賦值不會提升}test() 總結上述的 Hoisting 重點整理： 變數宣告跟函式宣告都會提升 只有宣告會提升，賦值不會提升 Hoisting 的順序Hoisting 其實是有優先順序的，按照順序來說是： function（函式） arguments（參數） var（宣告，這邊先忽略 let 和 const） Function 佔有優先權剛剛有提到 function 的順位是最優先的，怎麼說呢？我們直接來看範例： 123456789function test() { console.log(a) var a = 'local' function a() { }}test() // 回傳 [Function: a] 如果交換順序也是回傳 [Function: a] 123456789function test() { console.log(a) function a() { } var a = 'local'}test() // 回傳 [Function: a] 因為 Function 佔有優先權的關係，我們可以把上述程式碼解讀成： 123456789function test() { function a() { } console.log(a) a = 'local' // 因為前面已經有 function a，var 就不重要了}test() // 回傳 [Function: a] 如果有兩個重複的 function，哪個會佔優勢呢？ 123456789101112function test() { a() function a() { console.log(1) } function a() { console.log(2) } a = 'local'}test() // 回傳 2（後面的會蓋掉前面的） 其他範例一 1234567function test(a) { var a console.log(a) a = 456}test(123) // 回傳 123 但如果把 a 改成 undefined 事情就不一樣囉！ 1234567function test(a) { var a = undefined console.log(a) a = 456}test(123) // 回傳 undefined 其他範例二 12345678function test(a) { console.log(a) function a() { }}test(123) // 回傳 [Function: a] 其他範例三 123456callName();function callName() { console.log(name)}var name = 'Mily'// 回傳 undefind 其他範例三 123456789101112function callName() { console.log('Mily')}callName();function callName() { console.log('Lily')}callName();// 回傳：// Lily// Lily 最後小練習： 1234567891011121314151617181920var a = 1;function test(){ console.log('1.', a); // 1. undefined，因為函式有最高優先權，就會整段跑到 var a = 1 的上面 var a = 7; console.log('2.', a); // 2. 7 a++; // 7 + 1 = 8 var a; inner(); console.log('4.', a); // 4. 30 function inner(){ console.log('3.', a); // 3. 8 a = 30; b = 200; }}test();console.log('5.', a); // 5. 1a = 70;console.log('6.', a); // 6. 70console.log('7.', b); // 7. 200 Hoisting 好文推薦這次學習 Hoisting 時，除了本篇文章提到的這些重點以外，還學習了 JavaSript 執行環境、運作方式。雖然沒有針對執行環境寫筆記，為防以後複習時需要，這邊先附上讓我受益良多的文章： 《秒懂！JavaSript 執行環境與堆疊》 [第十七週] JavaScript 進階：打好基礎的第一步，從了解什麼是 EC 開始 [第十七週] JavaScript 進階：從 EC 來理解 Hoisting let 與 const 的詭異行為上述提到的 Hoisting，都是用 var 來宣告，接著來看看 let 與 const。 原本用 var 宣告： 12console.log(a) // 回傳 undefinedvar a = 10 如果改成 let 宣告呢？以下面的範例來看，可能會讓人以為 let 沒有 Hoisting 的行為。 12console.log(a) // 回傳 a is not definedlet a = 10 其實 let 是有 Hoisting 的，只是 Hoisting 的方式和我們想像中的不同。怎麼說呢？按照以下的範例來說： 1234567let a = 10function test() { console.log(a) let a = 30}test() // 回傳 a is not defined 如果 let 沒有 Hoisting 的話，就會變成接收到最外層 let a = 10 的參數來回傳 10 才對，可是這邊卻得到 a is not defined，由此可證 let 是有 Hoisting 的。 let 提升的方式如果是使用 var 宣告的話，賦值以前，變數會初始成 undefined 123456789101112131415161718function test() { console.log(a) var a = 30}test()// 上述程式碼提升後：function test() { var a // a = undefined console.log(a) // ... TDZ // ... TDZ // ... TDZ a = 30}test() 使用 let 宣告的話就不一樣了，在賦值以前都是無法存取變數的，如果嘗試存取就會出現 ReferenceError！而提升後，直到賦值之前的這段期間就叫做 TDZ（Temporal Dead Zone，亦稱暫時性死區）。 參考資料： 我知道你懂 hoisting，可是你了解到多深？ [week 16] JavaScript 進階 - 初探 Hoisting &amp; Execution Context","link":"/Front-End/JavaScript%20-%20%E6%B7%BA%E8%AB%87Hoisting/"},{"title":"JavaScript - 認識運算子","text":"此篇內容主要記載五種 JavaScript 運算子種類（算術、位元、位移、邏輯、條件）。 文章目錄 關於 false 算術運算子 位元運算子 位移運算子 邏輯運算子 條件運算子（三元運算子） 關於 false因為文章內會出現大量布林值，在深入了解運算子之前，我們要先知道什麼狀況會被當成 false。在 JavaScript 中，以下這些都會被當作是 false： null 0 NaN ''(空字串) undefined 算術運算子 運算子 說明 範例及說明 + 加法 2 + 3 回傳 5 - 減法 6 - 4 回傳 2 ++ 遞增 假如 x 是 3，那 ++x 將把 x 設定為 4 並回傳 4，而 x++ 會回傳 3 ， 接著才把 x 設定為 4 -- 遞減 假如 x 是 3，那 –x 將把 x 設定為 2 並回傳 2，而 x– 會回傳 3 ， 接著才把 x 設定為 2 * 乘法 2 * 5 回傳 10 / 除法 10 / 2 回傳 5 % 取餘數 10 % 3 回傳 1 ** 次方 2 ** 5 回傳 32 ++ 與 -- 123var a = 0a = a + 5 // 這句話可省略成：a += 5a = a - 5 // 這句話可省略成：a -= 5 a++（就是 a += 1），a– 反之 注意，++ 放前面或放後面的意思是不同的 位元運算子 運算子 符號 用法 AND &amp; a &amp; b OR XOR ^ a ^ b NOT ~ ~ a （說明待補） 位移運算子 運算子 用法 左移 a &lt;&lt; b 右移 a &gt;&gt; b 為什麼要用這個位移運算子？比起使用 * 這個符號，對於電腦來說二進位是電腦最原始的形式，所以使用位移運算子的效能會比較快。 右移 &gt;&gt; 與左移 &lt;&lt;&gt;&gt; 右移 n 位：可以想成乘以 2 的 n 次方&lt;&lt; 左移 n 位：可以想成除以 2 的 n 次方 範例： 123410 &lt;&lt; 1 // 回傳 2010 &lt;&lt; 3 // 回傳 80，這裡的 3 代表 2^31 &lt;&lt; 10 // 回傳 1024，這裡的 10 代表 2^101024 &gt;&gt; 1 // 回傳 512 邏輯運算子邏輯運算子總共有三個，分別是：AND、OR 與 NOT，通常被用於布林值（true / false），使用於布林值時， 它們會回傳布林型態的值。 1. 邏輯 OR (||)OR (||) 是「或」的意思，只要其中一邊是 true，即會是 true。 123true || true // 回傳 truetrue || false // 回傳 truefalse || true // 回傳 true OR (||) 的短路求值 短路求值是一種邏輯運算符的求值策略。只有當第一個運算數的值無法確定邏輯運算的結果時，才對第二個運算數進行求值。（取自維基百科） OR (||) 除了可以回傳布林值以外，其他類型也能做邏輯運算子。如果第一個遇到的值即為 true，即會回傳 true，不需再理會第二個值；如果兩邊都是 true，也會回傳第一個值。 123453 || 10 // 3 是 true，所以回傳 3false || 5 // 5 是 true，所以回傳 50 || 10 // 數值 0 在 JavaScript 中會被當作 false，所以回傳 10false || 10 // 回傳 101 == 2 || \"hello\" // 回傳 \"hello\" 設定變數預設值可以用於取代 if 判斷式，例如： 1let fruit = apple || banana 以上的意思是指，如果 apple 不存在就回傳 banana 簡化程式碼如果 obj 是 false 就呼叫 call() 函式 123if (!obj) { call()} 可以直接簡化成： 1(obj || call()) 同理，如果反過來是： 123if (obj) { call()} 就可以簡化成： 1(!obj || call()) 2. 邏輯 AND (&amp;&amp;)AND (&amp;&amp;) 的規則是兩個條件皆符合才會成立，所以第一個條件若不符合，程式碼就不會再往後執行。 第一個條件是 true 的話，就直接回傳第二個條件的數值 第一個條件是 false，就會回傳 false，而不再往後看後面的條件 1234567true &amp;&amp; true // 回傳 truetrue &amp;&amp; false // 回傳 false3 &amp;&amp; 10 // 回傳 1010 &amp;&amp; 3 // 回傳 3false &amp;&amp; 3 // 回傳 false3 &amp;&amp; false // 回傳 false0 &amp;&amp; 100 // 回傳 false，因為 0 在 JavaScript 中被當成 false 簡化程式碼原本是： 1234let a = 5;if (a == 5) { alert(\"a = 5\");} 可以簡化成： 12let a = 5;a == 5 &amp;&amp; alert(\"a = 5\") 原理是如果 a == 5 為 false，就不會執行後面的程式碼了 3. 邏輯 NOT (!)12!true // 負正得負，所以回傳 false!false // 負負得正，所以回傳 true 條件運算子（三元運算子）三元運算子可以當成 if … else 的簡化寫法語法是： 條件 ? 值 1 : 值 2 範例：原本用 if … else 的寫法 12345if (a &gt; b) { return \"yes\"} else { return \"no\"} 可以用三元運算子簡化成 1return a &gt; b? \"yes\" : \"no\" 參考資料： MDN - 運算式與運算子 Javascript 基礎打底系列 (三) - 邏輯運算子，與短路邏輯 (short circuit logic)","link":"/Front-End/JavaScript%20-%20%E8%AA%8D%E8%AD%98%E9%81%8B%E7%AE%97%E5%AD%90/"},{"title":"JavaScript - 變數與賦值","text":"目錄 什麼是變數 undefined 與 defined 變數的資料型別 原始型別（Primitive Type） NaN 是什麼 如何判斷 NaN #什麼狀況會出現 NaN 呢？ Object 物件 檢測變數的型別 賦值 = 變數與賦值原理 -LHS 與 RHS 變數運算小陷阱 什麼是變數可以將變數想像成「一個能夠裝東西的箱子」，我們可以幫這個箱子命名（例如：box），箱內能儲存一些東西，這樣就可以用我們命名的 box 來代指箱子裡所儲存的東西。 undefined 與 defined有宣告變數卻沒有賦值的話，n 的值會變成 undefined 12let a;console.log(a); // 印出 undefined 沒有宣告變數就直接使用會出現 ReferenceError: __ is not defined（未定義） 1console.log(a); // 出現 Uncaught ReferenceError: a is not defined 變數的資料型別變數沒有型別，值才有。 最新的 ECMAScript 標準定義了七種資料型別： 原始型別（Primitive Type） null undefined string number boolean symbol Object 物件 Primitive Type 和 object 的差別之一：Primitive Type 是不可改變的（Immutable） 123456789// Primitive Type 不可改變let str = \"hello\";str.toUpperCase(); //這一行回傳的是新的值，而不是改變舊的自己console.log(str); // 印出 hello// object 可以改變let arr = [1];arr.push(2);console.log(arr); // 印出 [1, 2] 原始型別（Primitive Type） 型別 名稱 說明 數值範例 Null 沒有值 「現在」沒有值（可能曾經有過） Undefined 未定義 已宣告卻尚未給值 String 字串型別 需用單引號或雙引號包夾住 “Hello”、’Hi’ Number 數字型別 除了常見的整數與小數點外，還包含 Infinity（無限大）、-Infinity（負無限大），以及 NaN 50、100 Boolean 布林值 值有 true 及 false 兩個值 true / false Symbol 符號型別 ES6 新推出的資料型別 NaN 是什麼？NaN：Not a Number 的縮寫，但其實型態仍為 Number。 1console.log(typeof NaN); // 印出 number 如何判斷 NaN可以使用：isNaN()，如果是 NaN 就會顯示 true；否就顯示 false（有些舊的瀏覽器可能不支援，就得找其他方法） 12let a = Number(\"hello\");console.log(isNaN(a)); // 印出 true 什麼狀況會出現 NaN 呢？1234567let a = Number(\"hello\");let b = \"hey\";let c = 30;console.log(a); // 印出 NaNconsole.log(b * c); // 印出 NaNconsole.log(typeof a); // 印出 number Object 物件 Object 物件 { } Array 陣列 [ ] Function 函式 function() {} Date 除了基本型別 (Primitives) 以外的值都是物件 檢測變數的型別 typeof Array.isArray([])（因為 typeof 沒辦法辨識 array，就可以使用這個語法來判斷 array） Object.prototype.toString.call() typeof如果想查詢變數是什麼型別可以用 typeof + 變數 來查詢。 1234console.log(typeof 30); // 印出 numberconsole.log(typeof \"Hello\"); // 印出 stringconsole.log(typeof undefined); // 印出 undefinedconsole.log(typeof true); // 印出 boolean 以下是幾個 typeof 令人容易混淆的地方（詳情可參考 MDN - typeof） 123console.log(typeof null); // 印出 object，這是 JavaScript 的「bug」console.log(typeof function () {}); // 印出 function（除了 function 以外的物件都是回傳 object）console.log(typeof []); // 印出 object，因為陣列歸類在 object 型別 從 typeof 沒辦法判斷變數是不是 array，所以可以利用 Array.isArray([]) 來判斷。（比較舊的瀏覽器可能不支援這個語法） 1console.log(Array.isArray([])); // 印出 true 變數使用 typeof 12console.log(a); // RefereneceError: a is not definedconsole.log(typeof a); // 印出 undefined 12let a;console.log(typeof a); // 印出 undefined，雖然有宣告，但沒有賦值 開發時可以利用 typeof 來檢查變數有沒有賦值： 12345678910if (typeof a !== \"undefined\") { console.log(a);}// 因為沒有賦值，所以不會回傳任何東西//如果不用 `typeof` 來判斷，會跑出 RefereneceError：if (a !== \"undefined\") { console.log(a);}// 印出 RefereneceError: a is not defined 12345let a = 10;if (typeof a !== \"undefined\") { console.log(a);}// 印出 10 Object.prototype.toString.call()12345console.log(Object.prototype.toString.call(1)); // 印出 [Object Number]console.log(Object.prototype.toString.call()); // 印出 [Object String]console.log(Object.prototype.toString.call([])); // 印出 [Object Array]console.log(Object.prototype.toString.call(new Date())); // 印出 [Object Date]console.log(Object.prototype.toString.call(null)); // 印出 [Object Null] 賦值 =在 JavaScript 中，變數的 = 並不是指數學符號的 =，指的是賦值。初學者可能會有誤把 = 當成 等於 的狀況使用，需要特別注意！ 123456let a = 10;if ((a = 20)) { // 此處是「賦值」 console.log(123);}// 印出 123 變數與賦值原理Primitive Type12345678910111213let a = 10let b = a// a: 10// b: 10（從 a copy 過去的）---------------// 所以當給 b 一個新的值時，就會直接改變let a = 10let b = ab = 20// a: 10// b: 20 Object12345678let obj = { number: 10,};let obj2 = obj;console.log(obj, obj2); // 印出 { number: 10} { number: 10}obj.number = 20;console.log(obj, obj2); // 印出 { number: 20} { number: 20} 上述程式碼的解析： 123456789101112131415161718let obj = { number: 10}// obj 的內容 {number: 10} 其實是放到某個記憶體位置上// 這裡先以 0x01 代表記憶體位置0x01: { number: 10}obj: 0x01 // 所以 obj 指的是 0x01 記憶體位置的東西let obj2 = obj // 當 obj2 宣告 = obj 時obj2: 0x01 // 其實是 copy obj 的記憶體位置obj.number = 20 // 其實是改變記憶體中的 number0x01: { number: 20}// 因此記載同樣記憶體的 obj 也會被影像// 所以 console.log(obj, obj2) 會印出 { number: 20} { number: 20} array 也是 object 的一種，所以同理可證： 12345let arr = [];let arr2 = arr;console.log(arr, arr2); // 印出 []arr2.push(\"arr2\");console.log(arr, arr2); // 印出 ['arr2', 'arr2'] 小陷阱： 12345let arr = [];let arr2 = arr;console.log(arr, arr2); // 印出 []arr2 = [\"arr2\"]; // 賦值原理：['arr2'] 是放在新的記憶體位置，此時 arr2 存取的記憶體位置和 arr 不同了console.log(arr, arr2); // 印出 [] [ 'arr2' ] LHS 與 RHSLHS 及 RHS 字面上的意思是左手邊（Left hand side）、右手邊（Right hand side），最簡單的方式是理解成賦值（=）操作的左側與右側（但這樣其實不夠精確！詳請可以往下看） LHSLHS（Left hand side）：賦值到左側的變數上 建議記成：請幫我去查這個變數的位置在哪裡，因為我要對它賦值。 這裡對 name 而言是 LHS 引用，因為我們的目的是把 a 賦值成 2 1let name = \"Mily\"; RHSRHS（Right hand side）：取值來自於右側的變數上 建議記成：請幫我查詢這個變數的值是什麼，因為我要用這個值。 此處 a 是一個 RHS 引用，因為 a 沒有賦值，我們的目的是為了取到 a 的值並用 console.log 印出。 1console.log(a); （詳細 LHS 與 RHS 的解釋可參考：快速理解 JavaScript 中的 LHS 和 RHS 查询） 變數運算小陷阱在使用變數做運算時，初學者容易忽略的陷阱有兩個，一是型別，二是浮點數誤差。 型別123let a = 10;let b = \"20\";console.log(a + b); // 印出 1020，因為 b 是字串，所以不會印出 30 浮點數誤差電腦在儲存小數點時沒有辦法真的很精準，所以會導致運算結果有些許誤差。 12let a = 0.1 + 0.2;console.log(a == 0.3); // 印出 false 為什麼是 false 呢？我們把 a 拆解來看，會發現奇妙的誤差，因此在使用小數點時需特別注意，或盡量減少使用小數點。 1console.log(a); // 印出 0.3000000004 參考資料： 重新認識 JavaScript: Day 03 變數與資料型別 我知道你懂 hoisting，可是你了解到多深？","link":"/Front-End/JavaScript%20-%20%E8%AE%8A%E6%95%B8%E8%88%87%E8%B3%A6%E5%80%BC/"},{"title":"React 基礎：React 中使用 CSS 的方式","text":"React 使用 CSS 的方式有幾種： inline-style 使用 webpack 打包 styled-components 套件 將變數傳入 JSX在開始講解 React 撰寫 CSS 的方式前，先來了解該怎麼將變數傳入 JSX。使用的方式很簡單，我們宣告一個名為 name 的變數，並在 JSX 中透過將其名稱包在大括號中，即可使用。以下範例取自官方文件： 1234567const name = 'Josh Perez';const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;; // 將變數名稱包在大括號 {} 中ReactDOM.render( element, document.getElementById('root')); 1. inline-style使用 inline-style 的方式有幾點需注意： 無法使用偽元素或 :hover 等效果。 CSS 屬性需改用駝峰式命名（因為是用 JavaScript 的方式撰寫）。 屬性分隔需使用逗號（因為是 JS 物件） 傳一個包含 CSS 屬性的 obeject： 12345678910const titleStyle = { color: 'red', rextAlign: 'center' // 駝峰式命名}function Title() { return ( &lt;h2 style={titleStyle}&gt;hello&lt;/h2&gt; ) } 一般來說可以省略宣告，直接把 obeject 放入 JSX： 12345678910function Title() { return ( // 第一個 {} 是將變數傳入 JSX 的方法 // 第二個 {} 是物件（要傳入的內容） &lt;h2 style={{ color: 'blue', textAlign: 'center' }}&gt;hello&lt;/h2&gt; ) } 2. 使用 webpack 打包class 是 JS 的保留字，所以在 JSX 的語法中，無法直接傳入 class，需改為 classNane 當作標籤的屬性。 123456789// 以下內容寫在 App.jsfunction App() { return ( &lt;div className=\"App\"&gt; &lt;Title /&gt; &lt;Description /&gt; &lt;/div&gt; );} 瀏覽器便會自動 render 成 class 名稱 12345/* 瀏覽器渲染後 */&lt;div class=\"App\"&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;p&gt;歡迎光臨&lt;/p&gt;&lt;/div&gt; 而因為 webpack 的關係，所以可以直接引入 CSS 檔案 1import './App.css'; 最後只要在 App.css 裡面撰寫內容即可！ 1234.App { text-align: center; background-color: #eee;} 同理，除了 CSS 以外，只要修改 webpack 設定，也能改成 SASS/SCSS 等撰寫方式。 3. styled-components 套件styled components 是 React 可以使用的一個 library，撰寫方式使用 ES6 的標籤模版（tagged template），是目前滿主流的用法。 tagged template 可以參考 PJCHENder 大大的文章：[筆記] JavaScript ES6 中的模版字符串（template literals）和標籤模版（tagged template） 首先，先安裝 styled-components，安裝方式取自官網文件 12345# 使用 npm 安裝npm install --save styled-components# 使用 yarn 安裝yarn add styled-components 將 styled-components 引入 12// 以下內容寫在 App.jsimport styled from 'styled-components'; 安裝套件及引入後，就可以開始撰寫 CSS 了！宣告一個名為 Description 的變數，這個變數可以想成：擁有 style 樣式的 p 標籤 123456789101112131415const Description = styled.p` display: inline-block; padding: 10px; border: 1px solid black; color: blue; font-size: 30px;`function App() { return ( &lt;Description&gt; // 定義完後就可以使用 歡迎光臨 &lt;/Description&gt; );} 瀏覽器 render 後的畫面： 使用開發者工具查看，可以發現 styled-components 自動產生亂數 class 名稱： styled-components 寫 CSS 的方式有點像 SCSS，如果要寫 :hover 效果或是底下的其他標籤可以這麼寫： 123456789101112131415const Description = styled.p` display: inline-block; padding: 10px; border: 1px solid black; color: blue; font-size: 30px; &amp;:hover { color: red; } span { color: green; }` styled-components 參數傳遞styled-components 可以搭配 props 來接受參數，藉次改變 CSS 樣式。三元運算子的範例： 1234567891011121314const TodoContent = styled.div` color: rgba(2, 40, 77); font-size: ${props =&gt; props.size === 'XL' ? '20px' : '12px'}`function App() { return ( &lt;div className=\"App\"&gt; &lt;TodoItemWrapper&gt; &lt;TodoContent size=\"XL\"&gt;I am todo&lt;/TodoContent&gt; &lt;/TodoItemWrapper&gt; &lt;/div&gt; );} 短路範例： 12345678const TodoContent = styled.div` color: rgba(2, 40, 77); font-size: 12px; ${props =&gt; props.size === 'XL' &amp;&amp; ` font-size: 20px; `}` 開啟開發者工具來檢查，會發現樣式已經被覆蓋掉了。 建立 component較常見的做法是會建立 component 來使用 1234567891011121314151617181920function TodoItem ({ size, content }) { return ( &lt;TodoItemWrapper&gt; &lt;TodoContent size={size}&gt;{ content }&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )}function App() { return ( &lt;div className=\"App\"&gt; &lt;TodoItem content={\"測試一\"} /&gt; &lt;TodoItem content={123} size=\"XL\" /&gt; &lt;/div&gt; );} 樣式繼承1234567891011121314// 原本const Button = styled.button` padding: 10px; color: #333; &amp; + &amp; { margin-left: 15px; }`// 重新定義const RedButton = styled(Button)` color: blue;` 如果是對 component 做 restyle，就要傳入 className 1234567891011121314151617181920212223242526function TodoItem ({ className, size, content }) { return ( &lt;TodoItemWrapper className={className}&gt; &lt;TodoContent size={size}&gt;{ content }&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )}// BlackTodoItem 會變成一個 classNameconst BlackTodoItem = styled(TodoItem)` background: black;`function App() { return ( &lt;div className=\"App\"&gt; &lt;TodoItem content={\"測試一\"} /&gt; // 使用 BlackTodoItem &lt;BlackTodoItem content={123} size=\"XL\" /&gt; &lt;/div&gt; );} Media Query基本寫法： 123456789const Button = styled.button` padding: 10px; color: #333; font-size: 20px; @media screen and (min-width: 768px) { font-size: 16px; }` 因為 Media Query 使用率高，建議直接寫成獨立檔案再引入，較便於重複使用。首先，放在路徑：src/constants/breakpoint.js ，並在裡面寫入： 12export const MEDIA_QUERY_MD = '@media screen and (min-width: 768px)'export const MEDIA_QUERY_LG = '@media screen and (min-width: 1000px)' 這樣即可在 App.js 引入並使用： 12345678910111213141516// 引入import { MEDIA_QUERY_MD, MEDIA_QUERY_LG} from './constants/breakpoint';const Button = styled.button` padding: 10px; color: #333; font-size: 20px; ${MEDIA_QUERY_MD} { font-size: 16px; } ${MEDIA_QUERY_LG} { font-size: 12px; }` 使用 Sass 變數先在 index.js 引入 ThemeProvider，並宣告變數： 12345678910111213141516171819// 引入import { ThemeProvider } from 'styled-components'// 宣告變數（theme 可自訂名稱）const theme = { colors: { red_300: '#ffb9b9', red_400: '#ff9595', red_500: '#ff7373', }}ReactDOM.render( // 用 ThemeProvider 包住 App 並傳入 theme 參數 &lt;ThemeProvider theme={theme}&gt; &lt;App /&gt; &lt;/ThemeProvider&gt;, document.getElementById('root')); 接著就可以回到 App.js 使用： 1234const TodoContent = styled.div` color: ${props =&gt; props.theme.colors.red_300}; font-size: 12px;` component 獨立檔案當專案變大時，會變得不好管理，所以可以將一些 component 獨立出來使用。範例：創建一個 components 的資料夾，裡面用來放置個蟲可以重複使用的 component，接著建立一個 TodoItem.js 的檔案，將 todolist 的相關語法都放進去，並用 export 指派函式。 123export default function TodoItem ({ className, size, content }) { // ... 內容省略} 回到 App.js 引入 1import TodoItem from './TodoItem' 參考資料： [第二十一週] React 基礎：如何寫 CSS","link":"/Front-End/React-%E5%9F%BA%E7%A4%8E%EF%BC%9AReact-%E4%B8%AD%E4%BD%BF%E7%94%A8-CSS-%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"title":"React 基礎：useState 實戰 Todo List","text":"React 最核心的觀念就是畫面永遠都由 state 產生 在 React 裡面分成兩種 component： function component class component 什麼是 HookHook 是 React 16.8 中新增的功能，能達到不寫 class 就能使用 state 以及其他 React 的功能。 開始使用 State Hook使用 state 前要先引入 React。 12// App.jsimport React from \"react\"; 宣告一個新的 state 變數，我們稱為 \b\b counter。 counter：state 的變數，存放 state 的值 setCounter：改變 state 變數的函式名稱 useState(0)：0 代表 state 變數的初始值 1234567// 如果沒有引入 import { useState } from 'react'; 就要在 .useState() 前面加上 React.const [counter, setCounter] = React.useState(0);// 如果有引入 import { useState } from 'react'; 就可以忽略 React.import { useState } from \"react\";const [counter, setCounter] = useState(0); 這句程式碼的原理其實就是 ES6 的解構語法。 12345function useState() { return [123, 456];}const [a, b] = React.useState(); // a, b 可以任意取名 使用範例： 12345678910111213function App() { const [counter, setCounter] = React.useState(0); const handleButtonClick = () =&gt; { setCounter(counter + 1); }; return ( &lt;div className=\"App\"&gt; counter: {counter} &lt;button onClick={handleButtonClick}&gt;increment&lt;/button&gt; &lt;/div&gt; );} Todo List 實戰開始實作前會先講解幾個需要注意的重點： React 處理陣列的方式 State 觀念：immutable 沒有內容的標籤 一、React 處理陣列的方式因為 JSX 無法使用迴圈語法，所以 render 時需使用函式達到目的，這次使用 map() 來處理陣列。使用 map() 的好處是把每個 array 的東西都 map() 成一個 component，就可以 render 出很多個 component。 先看不使用 map() 的做法： 123456789101112function App() { const [todos, setTodos] = useState([]); const handleButtonClick = () =&gt; {}; return ( &lt;div className=\"App\"&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {[&lt;TodoItem content={\"測試一\"} /&gt;, &lt;TodoItem content={\"測試二\"} /&gt;]} &lt;/div&gt; );} 使用 map() 的做法： 1234567891011121314function App() { const [todos, setTodos] = useState([\"測試一\", \"測試二\"]); const handleButtonClick = () =&gt; {}; return ( &lt;div className=\"App\"&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={index} content={todo} /&gt; ))} &lt;/div&gt; );} 用這種方式 render 的時候，要加入 key 值，否則會出現錯誤：index.js:1 Warning: Each child in a list should have a unique \"key\" prop.，這邊暫時先傳 index（但一般來說不建議傳 index），key 值是不能重複的。 二、State 觀念：immutablestate 有一個很重要的觀念是 immutable，當 React 判定新的 state 和舊的 state 一樣時，就不會做任何動作。 1234const handleButtonClick = () =&gt; { todos.push(\"測試三\"); // 執行完這行後，原本的 todo 會變成 [\"測試一\", \"測試二\", \"測試三\"] setTodos(todos); // 設置新的 todo}; 所以不能直接去改原本的 state，而是產生新的 state，比較推薦的寫法是： 123const handleButtonClick = () =&gt; { setTodos([\"測試三\", ...todos]); // 搭配 ES6 解構}; 三、沒有內容的標籤在 React 中，如果標籤沒有內容時，一定要在結尾加上 /。 12345// HTML 寫法，結尾可以沒有「/」&lt;input type=\"text\" placeholder=\"todo\"&gt;// React 寫法，結尾一定要有「/」&lt;input type=\"text\" placeholder=\"todo\" /&gt; 新增 Todo來實作新增事項的功能吧！ 1234567891011121314151617181920212223242526272829303132import TodoItem from \"./TodoItem\";import React from \"react\";import { useState } from \"react\";function App() { const [todos, setTodos] = useState([]); const [value, setValue] = useState(\"\"); const handleButtonClick = () =&gt; { setTodos([value, ...todos]); setValue(\"\"); // 做完就清空 setValue }; const handleInputChange = (e) =&gt; { setValue(e.target.value); }; return ( &lt;div className=\"App\"&gt; &lt;input type=\"text\" placeholder=\"todo\" value={value} onChange={handleInputChange} /&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={index} content={todo} /&gt; ))} &lt;/div&gt; );} 12345678910111213141516171819202122232425262728293031323334353637383940414243// TodoItem.js 檔案的內容const TodoItemWrapper = styled.div` display: flex; align-items: center; justify-content: space-between; padding: 8px 15px; border: 1px solid #ccc;`;const TodoContent = styled.div` color: ${(props) =&gt; props.theme.colors.primary_500}; font-size: 12px; ${(props) =&gt; props.size === \"XL\" &amp;&amp; ` font-size: 20px; `}`;const TodoButtonWrapper = styled.div``;const Button = styled.button` padding: 10px; color: #333; font-size: 20px; &amp; + &amp; { margin-left: 15px; }`;export default function TodoItem({ todo }) { return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; &lt;TodoContent&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; );} 幫 Todo List 加上 id第一種做法： 123456789101112131415161718192021222324252627282930313233343536let id = 2;function App() { const [todos, setTodos] = useState([{ id: 1, content: \"abc\" }]); const [value, setValue] = useState(\"\"); const handleButtonClick = () =&gt; { setTodos([ { id: id, content: value, }, ...todos, ]); setValue(\"\"); // 做完就清空 setValue id++; }; const handleInputChange = (e) =&gt; { setValue(e.target.value); }; return ( &lt;div className=\"App\"&gt; &lt;input type=\"text\" placeholder=\"todo\" value={value} onChange={handleInputChange} /&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={todo.id} content={todo.content} /&gt; ))} &lt;/div&gt; );} 第二種做法，使用 useRef： 1234567891011121314151617181920212223242526272829303132333435363738394041import { useState, useRef } from \"react\";function App() { const [todos, setTodos] = useState([ { id: 1, content: \"test content\" }, // 內建一筆資料 ]); const [value, setValue] = useState(\"\"); const id = useRef(2); // 上面已經有內建 id:1，所以初始值要從 2 開始 const handleButtonClick = () =&gt; { setTodos([ { id: id.current, content: value, }, ...todos, ]); setValue(\"\"); // 做完就清空 setValue id.current++; }; const handleInputChange = (e) =&gt; { setValue(e.target.value); }; return ( &lt;div className=\"App\"&gt; &lt;input type=\"text\" placeholder=\"todo\" value={value} onChange={handleInputChange} /&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={todo.id} todo={todo} /&gt; ))}{\" \"} // todo={todo} 傳入 todo 參數 &lt;/div&gt; );} 接著修改 TodoItem.js 1234567891011export default function TodoItem({ todo }) { return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; &lt;TodoContent&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; );} 成功得到 id： 實作刪除功能在 App.js（Parent 層） 定義一個 handleDeleteClick 的函式，裡面傳入 id，並用 handleDeleteClick={handleDeleteClick} 把函式傳到 TodoItem.js（Children 層） 1234567891011121314151617181920const handleDeleteClick = (id) =&gt; {};return ( &lt;div className=\"App\"&gt; &lt;input type=\"text\" placeholder=\"todo\" value={value} onChange={handleInputChange} /&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={todo.id} todo={todo} handleDeleteClick={handleDeleteClick} /&gt; ))} &lt;/div&gt;); 接著到 TodoItem.js 接收 handleDeleteClick 函式，就可以利用按鈕的監聽事件來呼叫 handleDeleteClick 函式，todo.id 即可傳回 Parent 層。 1234567891011121314151617export default function TodoItem({ todo, handleDeleteClick }) { return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; &lt;TodoContent&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;已完成&lt;/Button&gt; &lt;Button onClick={() =&gt; { handleDeleteClick(todo.id); }} &gt; 刪除 &lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; );} 最後再回 App.js（Parent 層）修改函式，即可完成刪除功能！ 1234const handleDeleteClick = (id) =&gt; { setTodos(todos.filter((todo) =&gt; todo.id !== id)); // filter 只會留下符合條件的東西，而 todo.id 一定等於 id，這代表不會留下任何東西，即可達成刪除功能}; // 不能使用 splice()，因為會改到原本的 todo，所以此處使用 filter() 更改 todo 的狀態先前的資料結構只有紀錄 id 和內容，為了能夠更改 todo 的狀態，要再新增 isDone: ?。 123456const [todos, setTodos] = useState([ { id: 1, content: \"test content\", isDone: true }, { id: 2, content: \"not done\", isDone: false },]);const [value, setValue] = useState(\"\");const id = useRef(3); 接著到 TodoItem.js 檔案寫判斷 todo 狀態的語法，不過特別要注意的是 React 沒有辦法寫 if 判斷式，所以我們改用三元運算子來判斷。&lt;TodoContent&gt; 寫入 isDone={todo.isDone} 來傳參數。 123456789101112131415161718export default function TodoItem({ todo, handleDeleteClick }) { return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; // isDone 前面加個 $ 就可以不讓「值」傳到 DOM 上面（不顯示在 HTML 的意思） &lt;TodoContent $isDone={todo.isDone}&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button&gt;{todo.isDone ? \"未完成\" : \"已完成\"}&lt;/Button&gt; &lt;Button onClick={() =&gt; { handleDeleteClick(todo.id); }} &gt; 刪除 &lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; );} 然後到 TodoContent 修改將傳入的參數（props） 12345678910const TodoContent = styled.div` color: ${(props) =&gt; props.theme.colors.primary_500}; font-size: 12px; ${(props) =&gt; props.$isDone &amp;&amp; ` text-decoration: line-through; `}`; 加上編輯狀態功能在 App.js（Parent 層） 定義一個 handleToggleClick 的函式，裡面傳入 id，並用 handleToggleClick={handleToggleClick} 把函式傳到 TodoItem.js（Children 層） 1234567891011121314151617181920212223242526272829303132333435const handleToggleClick = (id) =&gt; { setTodos( todos.map((todo) =&gt; { // 如果這個 todo 不是要修改的 todo id 就回傳原本的 todo if (todo.id !== id) return todo; // 進入這一行就代表是要修改的 todo.id // 回傳原本的東西（...todo）+ 要修改的屬性（isDone: !todo.isDone） return { ...todo, isDone: !todo.isDone, }; }) );};return ( &lt;div className=\"App\"&gt; &lt;input type=\"text\" placeholder=\"todo\" value={value} onChange={handleInputChange} /&gt; &lt;button onClick={handleButtonClick}&gt;Add todo&lt;/button&gt; {todos.map((todo) =&gt; ( &lt;TodoItem key={todo.id} todo={todo} handleDeleteClick={handleDeleteClick} handleToggleClick={handleToggleClick} /&gt; ))} &lt;/div&gt;); 接著到 TodoItem.js 接收 handleToggleClick 函式，就可以利用按鈕的監聽事件來呼叫 handleToggleClick 函式，todo.id 即可傳回 Parent 層。 123456789101112131415161718// inline function 的寫法export default function TodoItem ({ todo, handleDeleteClick, handleToggleClick }) { return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; &lt;TodoContent $isDone={todo.isDone}&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button onClick={() =&gt; { handleToggleClick(todo.id) }&gt; {todo.isDone ? '未完成' : '已完成'} &lt;/Button&gt; &lt;Button onClick={() =&gt; { handleDeleteClick(todo.id) }}&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; )} inline function（刪除功能跟編輯狀態的功能）也可以抽出來： 1234567891011121314151617181920212223242526// inline function 的寫法export default function TodoItem({ todo, handleDeleteTodo, handleToggleIsDone,}) { // inline function 抽出來 const handleToggleClick = () =&gt; { handleToggleIsDone(todo.id); }; // inline function 抽出來 const handleDeleteClick = () =&gt; { handleDeleteTodo(todo.id); }; return ( &lt;TodoItemWrapper data-todo-id={todo.id}&gt; &lt;TodoContent $isDone={todo.isDone}&gt;{todo.content}&lt;/TodoContent&gt; &lt;TodoButtonWrapper&gt; &lt;Button onClick={handleToggleClick}&gt; {todo.isDone ? \"未完成\" : \"已完成\"} &lt;/Button&gt; &lt;Button onClick={handleDeleteClick}&gt;刪除&lt;/Button&gt; &lt;/TodoButtonWrapper&gt; &lt;/TodoItemWrapper&gt; );} 總整理這次透過實作 Todo list 可以學到幾個 React 的基本概念： Component（利用 Component 思考頁面 UI） Props（就像自訂的 HTML 屬性，可以自行傳入需要的 Props） Style（詳見 React 基礎：React 中使用 CSS 的方式） Event handle（事件處理，這次示範的是 onClick） JSX 語法 State 在 React 新增、編輯、刪除的功能，雖然有其他方法可以實作，但基本上仍以下面的方法實作最為推薦。新增：解構語法編輯：map()刪除：filter() 參考資料： 【Day 5】 第一個 hook - useState","link":"/Front-End/React-%E5%9F%BA%E7%A4%8E%EF%BC%9AuseState%20%E5%AF%A6%E6%88%B0%20Todo%20List/"},{"title":"基礎環境建置 – Terminal、Git","text":"俗話說工欲善其事，必先利其器，在開始學習程式之前，先來建置電腦環境吧！這篇筆記主要記載我在建置環境時遇到的疑難雜症。 安裝的工具總共有： Homebrew（macOS 系統的套件管理工具） Git（一套能夠管理檔案的版本的程式 ） iTerm2（用於取代 MAC 原生終端機的工具） zsh（Z shell－維基百科） oh-my-zsh（zsh 的懶人包版本，已經先載好一些主題、外掛和設定） 安裝 Git安裝 Git 的方法有幾種，我選擇的方法是按照 Git 官網 說明，利用 Homebrew 套件管理工具來進行安裝，安裝完畢後按照指示在終端機輸入 $ brew install git ，並完成 Git 安裝。 這邊要特別注意的是，如果安裝過程出現 git -bash: $: command not found 時，請記得把 $ 拿掉。 iTerm2因為 Mac 本身內建的終端機樣式較少，所以可以自行斟酌是否要安裝其他 Terminal，這邊推薦使用 iTerm2，安裝方式我參考 超簡單！十分鐘打造漂亮又好用的 zsh command line 環境 來進行安裝，但因為文章比較舊，在安裝過程上有一些步驟需要更新，以下紀錄我所遇到的問題及解法： 1. 字體安裝遇到字體安裝的問題，在原文中安裝的步驟是寫： # 先執行這行，才能用 homebrew 安裝字型（曾經執行過的人可以跳過這個指令）brew tap caskroom/fonts# 安裝指令brew cask install font-sourcecodepro-nerd-font 但實際運行 brew tap caskroom/fonts 這句時，卻會報錯出現 Error: caskroom/fonts was moved. Tap homebrew/cask-fonts instead. 解法：brew tap caskroom/fonts 改成 brew tap homebrew/cask-fonts 即可解決 2. 安裝其他字型文中所提到若想安裝其他字型可輸入 brew cask search nerd 來搜尋，但此指令已不能再使用，需 解法：改為 brew search nerd 安裝 zsh theme安裝完 oh-my-zsh 後，最後就是安裝 zsh theme 的步驟，可是在安裝 zsh theme 時，因為對終端機指令不太熟悉，我卡很久，一直不太懂編輯 ~/.zshrc 是什麼意思，後來才知道這是一個隱藏的檔案，需要先打開來做設定。 打開 ~/.zshrc 的方式有兩種： 打開 Finder，按下快捷鍵 Command ⌘ + Shift + . ，即可顯示出隱藏檔案 .zshrc。 在 Terminal 直接輸入 open ~/.zshrc，系統即會直接打開檔案。 環境建置完成以上問題皆排除後，即可完成基礎環境建置。 參考資料： 安裝 homebrew cask 報錯問題 brew caskでフォントを入れる方法 #homebrew brew cask search が使えなくなったので brew search を使います [心得] iTerm2 + zsh，打造更好的工作環境","link":"/Others/%E5%9F%BA%E7%A4%8E%E7%92%B0%E5%A2%83%E5%BB%BA%E7%BD%AE%E2%80%93Terminal%E3%80%81Git/"},{"title":"認識版本控制與 Git 時光機","text":"什麼是版本控制？ 版本控制指的是把製作過程中的每個版本都保存下來，主要分成個人或團隊的版本控制。 一個人的版本控制版本控制是每個人從學生時期就學會的技能。「版本控制？我真的沒學過耶？」你可能會這麼說。 來，我們先看張圖： 不管是什麼類型的檔案格式，有沒有覺得這個畫面似曾相識？以前在繳交報告前，是不是前前後後備份了好幾個版本？其實這也是版本控制的一種，缺點是沒辦法清楚看見每個版本的差異性，時間久了也難以管理。 團隊的版本控制（待補圖） 什麼是 Git？Git 是一套能管理檔案版本，並達到做版本控制的程式，除了可以作為個人使用，也能用在多人協作上。 Git 紀錄的不是整份檔案，而是「檔案的異動」 Git 的優點： 免費 開源 速度快 檔案體積小 分散式系統 開始時光機旅程首先，先建立一個需要版本控制的目錄，開始這次的使用 Git 練習。 資料庫初始化git init：初始化目錄，讓 Git 對這個目錄開始進行版本控制。使用完這個指令後，主目錄裡面將會出現一個隱藏的 .git 目錄，裡面的內容是整個 Git 的精華，也是用這些內容來進行版本控制的。 如果這個目錄不想再使用 Git 控制呢？只要把 .git 目錄刪除即可。 ※ 注意：整個專案目錄內，任何檔案刪除都有辦法回朔，但誤把 .git 刪除就真的沒辦法了。 查詢狀態git status：查詢當前目錄的狀態。 常使用的指令，建議有事沒事就可以使用這個指令確認狀態。 把檔案交給 Gitgit add：決定檔案是否進行版本控制。 假設目前有這些檔案：code.jsnote.txtstyle.css 先把以上檔案移至目錄內，並輸入 git status 查詢狀態，即可得到這些檔案目前未被版本控制的訊息。 接下來輸入 git add code.js ，讓 code.js 加入版本控制並查看狀態，會發現檔案被分成兩個區域： staged：（有版本控制） untracked（沒有版本控制） 不小心忘記的話，CLI 畫面上很貼心的提示了取消版本控制的指令：git rm --cached &lt;檔案&gt; 如果不想要一個一個檔案慢慢輸入的話，可以輸入 git add .，即可一口氣把目前所在目錄中的所有檔案都加入版本控制。 新建一個版本git commit：新建一個版本。 當專案都完成了以後，就可以輸入 git commit 開始建立第一個版本，輸入完會進入 Vim 編輯器，可以把比較長的 commit message 在 Vim 裡面輸入，如果不想進去 Vim 裡面，可以直接輸入 git commit -m \"想要輸入的 commit message\"（推薦）。 完成後再輸入一次git status 確認狀態，即會發現不同之處。 Before After 注意！只要有更新都要照這些指令完成版本控制： git add &lt;file&gt; 或 git add . git commit + 進入 Vim 裡面輸入 commit message（或輸入 git commit -m \"想要輸入的 commit message\"，差別在於不進入 Vim） 組合指令：git commit -am '想要輸入的 commit message' 查看歷史紀錄git log：查看檔案詳細資訊。輸入後會進入詳細資訊的畫面查看，內容包含：包含版本號碼、作者、提交時間、commit message，離開的話可以按 :q 離開 git log --oneline：查看檔案重要資料。這個指令和 git log 的差別是只會顯示 7 碼版本號碼、commit message。 進入時光機如果玩過單機遊戲的應該都聽過 SL大法（Save、Load），git checkout 這個指令就是 Git 版的 Load 法（讀取紀錄），能夠輕鬆切換版本的重要指令。 git checkout + 版本號碼：切換至指定版本 git checkout master ：切換到最新版本 Git 中的邊緣人.gitignore：任何放在裡面的檔案都不會加到版本控制 使用方式： 先建立 .gitignore 檔案 用 vim 打開 .gitignore 編輯 在裡面輸入不加入版本控制的檔名 存檔後使用 git status 檢查 此指令大多用來放置不重要的檔案，例如：作業系統相關檔案、使用者個人設定、電腦暫存檔等 比對兩個版本之間的差異git diff：用來查看版本間的差異。 參考：30 天精通 Git 版本控管 (09)：比對檔案與版本差異 Git 基本流程懶人包 git init 建立 .gitignore，把不需加入版本控制的檔案先放入 輸入 git add .，先把所有檔案加入追蹤 輸入 git commit -am 'commit message' 建立版本控制 如此即完成專案第一個版本 如果有新增的檔案：一定先輸入 git add &lt;file&gt; 或 git add .，再打 git commit -am 'commit message' 如果僅編輯現有檔案：直接打 git commit -am 'commit message' 就好 Git 時光機進階篇 - 使用 Branch為什麼需要 Branch？在一個專案確定上線後，如果中途遇到 Bug 想修正，或者想要新增功能時，如果直接在專案上修正或測試，可能會影響到使用者，最理想的方式是建立分支，並在分支測試及開發，最後確認沒問題再合併回原本的專案，就不會影響到使用者。 指令介紹git branch + 名稱：建立新的 Branchgit branch -v：看目前有哪些 Branch 可簡寫指令成：gb -v git branch -m &lt;新名稱&gt;：修改 branch 的名字 git branch -d + 名稱：可以刪除指定的 Branchgit checkout + branch名稱：可以切換到指定的 Branch git merge：將 Branch 分支合併進 Master 版本 發生衝突：conflict在使用 git merge 後可能會遇到提示寫說conflict，代表兩個版本有衝突，解決方式是手動修改完成，存檔再 commit 即可。 使用分支進行專案開發新功能的流程 先使用 git branch &lt;branch 名稱&gt; 來建立新的 Branch git checkout，切換到新的 Branch 繼續開發新功能 開發完成後，git checkout 回原本的 Master git merge + 新 Branch 名稱，把新的 Branch 合併回 Master 沒衝突即完成（若有衝突就先解決完衝突再存檔並 commit 即可） Git 狀況劇commit 了，但是想再修改 commit message輸入 git commit --amend，會開啟 Vim 編輯模式，即可修改 commit message commit 後，反悔不想 commit 了git reset HEAD^：回到上一個 commit，還原檔案狀態 可以在後面加上模式： --soft（完整指令：git reset HEAD^ --soft） 這個指令的好處是，會保留檔案修改過的時候，但又能恢復到 commit 前（最常使用的做法） --hard（完整指令：git reset HEAD^ --hard），代表強制回去上一個 commit，把剛剛反悔的 commit 當作沒發生過，修改的檔案也會恢復未修改的狀態(最極端的做法) 欲了解詳情可以參考：【狀況題】剛才的 Commit 後悔了，想要拆掉重做… 還沒 commit，但修改的東西不想要了git checkout -- &lt;file&gt;：還原 “檔案內容” 客製化各個階段：Git hook什麼是 Hook？發生某件事的時候通知我（例如：有人 push 時、有人 commit 時） 指令懶人包 指令 說明 用法 init 初始化目錄 git init status 查詢當前目錄的狀態 git status init 決定檔案是否進行版本控制 git add add 初始化目錄 git init 參考資料： Git 教學 - Git 書 - 為你自己學 Git | 高見龍 gitbooks","link":"/Others/%E8%AA%8D%E8%AD%98%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E8%88%87%20Git%20%E6%99%82%E5%85%89%E6%A9%9F/"}],"tags":[{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"程式導師計畫","slug":"Lidemy","link":"/tags/Lidemy/"},{"name":"Others","slug":"Others","link":"/tags/Others/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Git","slug":"Git","link":"/tags/Git/"}],"categories":[{"name":"Front-End","slug":"Front-End","link":"/categories/Front-End/"},{"name":"Others","slug":"Others","link":"/categories/Others/"}]}